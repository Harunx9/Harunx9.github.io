<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Programming warfare - Gamedev</title><link href="http://localhost:8000/" rel="alternate"></link><link href="http://localhost:8000/feeds/gamedev.atom.xml" rel="self"></link><id>http://localhost:8000/</id><updated>2017-10-04T08:00:00+02:00</updated><entry><title>2DXngine update wersja 0.2.x-alpha</title><link href="http://localhost:8000/2dxngine-update-wersja-02x-alpha.html" rel="alternate"></link><published>2017-10-04T08:00:00+02:00</published><updated>2017-10-04T08:00:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-10-04:/2dxngine-update-wersja-02x-alpha.html</id><summary type="html">&lt;p&gt;Cześć. Od Daj się poznać 2017 minęło kilka miesięcy, więc czas na mały update tego co w 2DXngine się dzieje. Jak widzicie nie poddałem się i nadal rozwijam framework oraz dodaje nowe funkcjonalności. Co zatem się zmieniło od ostatniego razu? Jest tego dość sporo, więc mogę coś niechcący pominąć. Ostatni …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć. Od Daj się poznać 2017 minęło kilka miesięcy, więc czas na mały update tego co w 2DXngine się dzieje. Jak widzicie nie poddałem się i nadal rozwijam framework oraz dodaje nowe funkcjonalności. Co zatem się zmieniło od ostatniego razu? Jest tego dość sporo, więc mogę coś niechcący pominąć. Ostatni update miał miejsce jakoś w maju lub początkiem czerwca, w tym czasie silnik zyskał sporo elementów i udało mi się pozbyć masy błędów oraz  bugów.
Na początek może lista co się udało zrobić jako nowe elementy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bazowe komponenty 2D,&lt;/li&gt;
&lt;li&gt;podpięcie do CI,&lt;/li&gt;
&lt;li&gt;podstawowe MVP narzędzi do silnika, &lt;/li&gt;
&lt;li&gt;logger, Renderowanie multi render target, PostProcessing,&lt;/li&gt;
&lt;li&gt;integracja z Tiled,&lt;/li&gt;
&lt;li&gt;Itp. Itd.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Teraz przejdźmy do konkretów. Jeżeli chodzi o komponenty bazowe to w ramach tego powstały elementy pozwalające na wyświetlanie spriteów, animacji poklatkowych, obłsugę transformacji 2d, kolizje itp. Ilość komponentów będzie pewnie rosła, ale na razie zaimplementowane zostało niezbędne minimum. Kolejnym fajnym krokiem jest podpięcie silnika do CI AppVeyor jest to usługa, która pozwala na kompilacje, testowanie, release naszych aplikacji. Na razie ogarnąłem tylko build i testy o czym pisałem w &lt;a href="https://harunx9.github.io/appveynor-darmowe-ci-dla-projektow-open-source.html#appveynor-darmowe-ci-dla-projektow-open-source"&gt;TYM&lt;/a&gt; artykule. &lt;/p&gt;
&lt;p&gt;Kolejnym elementem jaki rozpocząłem z rzeczy około silnika są narzędzia, na razie jest to MVP texture packera, ponieważ musiałem to zrobić dla testów. Dalsza implementacja oczywiście nastąpi, ale silnik ma obecnie większy priorytet. Nażedzia są pisane w .NET CORE tak, że są muliplatformowe. Ciekawym elementem jest integracja z &lt;a href="http://www.mapeditor.org/"&gt;Tiled&lt;/a&gt;. Daje ona możliwość sparsowania mapy, ale i tworzenia całych scen. Cały mechanizm omówię osobno w innym artykule. 
Z innych rzeczy udało mi się dodać logowanie do konsoli wraz z ustaleniem poziomu logowania, post processing oraz renderowanie sceny na wielu render targetach i sklejanie ich potem osobno.&lt;/p&gt;
&lt;p&gt;To były co ważniejsze rzeczy jak myślę. Teraz co dalej i kiedy wyście z alfy tak na prawdę myślę, że wersja 0.3 powinna już być betą. Do tego czasu musze zastąpić MS bulid multiplatformowym Cmake i wykonać jeszcze parę testów z renderowaniem tile map. Jeżeli chodzi o przyszłość to chcę zrobić releasowanie silnika, jako statycznej biblioteki oraz generowanie projektu z silnikiem, exe i wszystkimi potrzebnymi zależnościami. Takie podejście mocno usprawni pracę z silnikiem, ponieważ obecnie należy ściągnąć silnik usunąć elementy z testowego projektu i dopiero wtedy można zaczynać prace. Nowe podejście powinno wygenerować projekt z kodzikiem silnika oraz drugim projektem, który ma być implementacją gry.&lt;/p&gt;
&lt;p&gt;To tyle. Jak chcesz to zapraszam do spróbowania 2DXngine do jakiś małych projektów. Oczywiście jak zawsze zapraszam do sekcji komentarzy.&lt;/p&gt;</content><category term="2DXngine"></category></entry><entry><title>SDL_mixer, czyli szybka implementacja audio</title><link href="http://localhost:8000/sdl_mixer-czyli-szybka-implementacja-audio.html" rel="alternate"></link><published>2017-07-09T21:20:00+02:00</published><updated>2017-07-09T21:20:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-07-09:/sdl_mixer-czyli-szybka-implementacja-audio.html</id><summary type="html">&lt;p&gt;Prawdopodobnie każdy twórca gier chce, by jego gra powodowała większą immersję, dlatego też należałoby do niej dodać oprócz grafiki takżę dźwięk oraz muzykę. 
Ze względu na to, że 2DXngine używa SDL2 postanowiłem iść dalej tą drogą i do odczytywania wykorzystać plugin SDL_mixer. Jest to mała wtyczka do SDL2, która pozwala …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Prawdopodobnie każdy twórca gier chce, by jego gra powodowała większą immersję, dlatego też należałoby do niej dodać oprócz grafiki takżę dźwięk oraz muzykę. 
Ze względu na to, że 2DXngine używa SDL2 postanowiłem iść dalej tą drogą i do odczytywania wykorzystać plugin SDL_mixer. Jest to mała wtyczka do SDL2, która pozwala odczytywać muzykę i dźwięki w różnych formatach. Moje rozwiązanie jest oparte o klasy i przyjrzymy się mu w perspektywie plików MP3 i WAV. 
Muzyka i dźwięki posiadają swoje klasy bazowe Sound i Music, które wyglądają w następujący sposób:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;SoundState&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;STOPPED&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;PLAYING&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;PAUSED&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Sound&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Asset&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;SoundState&lt;/span&gt; &lt;span class="n"&gt;_currentState&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Sound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AssetPath&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;AssetType&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Asset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Sound&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;play&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;repeat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;pause&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;resume&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;SoundState&lt;/span&gt; &lt;span class="nf"&gt;get_soundState&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_currentState&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Music&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Asset&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;SoundState&lt;/span&gt; &lt;span class="n"&gt;_currentState&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AssetPath&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;AssetType&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Asset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;play&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;repeat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;pause&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;resume&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;SoundState&lt;/span&gt; &lt;span class="nf"&gt;get_musicState&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_currentState&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;W przypadku pliku MP3 ładowanie pliku odbywa się w następujący sposób:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Mp3Sound&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mp3Sound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AssetPath&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DefaultAssetType&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;MP3_TYPE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;fPathStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_fullPath&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;soundPath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fPathStr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_str&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_musicData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mix_LoadMUS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;soundPath&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_currentState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SoundState&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;STOPPED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;W przypadku Wav wygląda to podobnie tylko funkcja Mix_LoadMUS(const char&lt;em&gt; path) zamienia się na Mix_LoadWAV(const char&lt;/em&gt; path). Różnice występują natomiast w odtwarzaniu, aby odegrać muzykę używam serwisu MusicService, który trzyma referencje na odgrywany kawałek. Za jego pomocą mogę również zatrzymywać, wznawiać lub zakończyć odrywanie danej muzyki.
W przypadku dźwięku sprawa ma się nieco inaczej, o ile muzyka odpaloną jedną ścieżkę na raz to dźwięki można ze sobą mixować i odpalać je kilka w jednym czasie. W tym przypadku w SoundService inicjalizuję kanały dla dźwięku zanim zacznę serwisu używać:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Mix_AllocateChannels&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Jest to o tyle ważne, ponieważ podczas odtwarzania dźwięku pobieramy pierwszy wolny kanał i na nim odtwarzamy dźwięk, jeżeli chcemy potem zatrzymać dźwięk to musimy podać kanał na którym odgrywany jest dźwięk. W mojej implementacji wygląda to następująco:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;WavSound&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;play&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;repeat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;repeat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_channel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mix_PlayChannel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_soundData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_channel&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_currentState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SoundState&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PLAYING&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;WavSound&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pause&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Mix_Pause&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_channel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_currentState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SoundState&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PAUSED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;WavSound&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Mix_HaltChannel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_channel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_channel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_currentState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SoundState&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;STOPPED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Oprócz MP3 zaimplementowałem jeszcze format OGG. Zobaczymy czy go będę używał, ale jakby ktoś potrzebował to jest. Zobaczymy jak muzyka będzie się sprawowała podczas implementacji gry, ale na razie z testów wynika, że powinno być ok. To chyba wszystko w temacie SDL_mixer w razie gdybym czegoś się jeszcze w tym temacie dowiedział, to opiszę na blogu.&lt;/p&gt;</content><category term="Gamedev"></category></entry><entry><title>Gamedev przegląd technologii</title><link href="http://localhost:8000/gamedev-przeglad-technologii.html" rel="alternate"></link><published>2017-05-09T20:50:00+02:00</published><updated>2017-05-09T20:50:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-05-09:/gamedev-przeglad-technologii.html</id><summary type="html">&lt;p&gt;Cześć. Dziś taki post z kategorii teoretyczno-poradnikowej. Mowa tu będzie o technologiach jakie polecam do tworzenia gier i dlaczego moim zdaniem ta a nie inna jest fajna. Traktujecie te przemyślenia nie jak prawdę objawioną, ale jako moje przemyślenia z perspektywy czasu. Od razu na początku chcę powiedzieć, że nie będzie …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć. Dziś taki post z kategorii teoretyczno-poradnikowej. Mowa tu będzie o technologiach jakie polecam do tworzenia gier i dlaczego moim zdaniem ta a nie inna jest fajna. Traktujecie te przemyślenia nie jak prawdę objawioną, ale jako moje przemyślenia z perspektywy czasu. Od razu na początku chcę powiedzieć, że nie będzie w tym przeglądzie o Unity3D lub Unreal Engine, ponieważ żadną z tych technologii nie bawiłem się na tyle długo, aby mój osąd był konstruktywny. Tworząc gry wychodzę z założenia, że sam chce stworzyć technologię dlatego, że wtedy lepiej rozwinę się jako programista, a o to w tym wszystkim chodzi.  &lt;/p&gt;
&lt;p&gt;Generalnie można przyjąć, że każdy język programowania posiadający biblioteki do obsługi GPU może służyć do programowania gier, ale jedne mają ciekawsze propozycje od innych. Rozpocznijmy od języków kompilowanych do kodu maszynowego, czyli takich bez środowiska uruchomieniowego. W tej kategorii najbardziej popularny jest C/C++. Jest to również standard, jeżeli chodzi o branżę grową. Takie tytuły jak Wiedźmin, Battlefield  czy Call of Duty są w większości napisane w C++, z dodatkiem języków skryptowych (Lua, Python). Jeżeli chodzi o biblioteki jakie upraszczają prace to jest ich również masa - SDL, Allegro, GLFW, itd. Oczywiście można też zaimplementować wszystko samemu, ale jest to proces długi i skomplikowany, a prace trzeba sobie ułatwiać. Z innych języków to słyszałem że, D jest również ciekawym  wyborem. Ja osobiście próbowałem bawić się językiem Rust - jest to dość ciekawa technologia, ponieważ nie jest to język obiektowy a strukturalny. Dodatkowo zarządzanie pamięcią odbywa się poprzez smart pointery. Posiada on też ciekawy system modułów oraz parę bibliotek graficznych.&lt;/p&gt;
&lt;p&gt;Kolejnymi technologami jakimi chciałem się przyjrzeć, są języki działające na maszynach wirtualnych z JIT. Tu prym od lat wiedzie Jvm i .NET. Jeżeli chodzi o Jvm to w ostatnich latach pojawiło się na nim parę ciekawych języków, ale nie miałem okazji używać żadnego z nich poza samą Javą. Z popularnych bibliotek do produkcji gier należałoby wymienić LibGDX -ciężko to nazwać jeszcze biblioteką, ponieważ dba ona o bardzo dużo spraw: zarządzanie scenami, aktor system, kontrolki, assety. Pozwala on tworzyć gry multiplatformowe, więc może być całkiem ciekawą opcją. Mniej popularnymi bibliotekami dla Jvm to: AndEngine, jMonkey, LWJGL i inne. W .NET do pewnego momentu był lekki nieurodzaj, jeżeli chodzi o frameworki do tworzenia gier. Obecnie mocno się to zmieniło i w .NET mamy oprócz popularnego Unity 3D trochę mniejszych bibliotek. Z ciekawszych propozycji to można spróbować Monogame, WaveEngine, Xenko. Jeżeli ktoś chciałby zejść niżej to polecam OpenTK (Open GL) lub SharpDX (DirectX).&lt;/p&gt;
&lt;p&gt;Ostatnią kategorią są języki skryptowe, na tym polu mamy takie technologie jak: Python, Ruby, PHP, JavaScript, Lua i wiele innych. Z rzeczy którymi, sam osobiście się bawiłem to PyGame dla Pythona -  jest to dość prosta biblioteczka, która pozwala na stworzenie dość szybko prototypu gry, z tego co wiem jest częściowo oparta o SDL. Z drugiej strony, jeżeli chcemy tworzyć gry pod przeglądarki internetowe to polecam pobawić się opartym na JavaScript Phaserem. Ja osobiście chwile pobawiłem się Phaserem tyle, że nie w czystym JavaScript, a w TypeScript i tą drogę również wam polecam, ponieważ TS mocno ułatwia pisanie i strukturyzację kodu, dzięki silnemu typowaniu. Moim zdaniem języki skryptowe nadają się jednak tylko i wyłącznie do prototypowania. Pozwalają one stworzyć szybko coś co możemy pokazać, natomiast dalszy rozwój powinien się obyć w szybszej technologii (C++, Jvm, .NET). &lt;/p&gt;
&lt;p&gt;To tyle, mam nadzieję, że nie zraziłem nikogo, tak jak już pisałem to są wyłącznie moje przemyślenia i każdy może próbować w JS tworzyć nowego Wiedźmina czy innego COD możliwe, że efekty pracy będą całkiem ciekawe.&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category></entry><entry><title>2DXngine: Renderowanie 2D i inne informacje</title><link href="http://localhost:8000/2dxngine-renderowanie-2d-i-inne-informacje.html" rel="alternate"></link><published>2017-05-06T10:00:00+02:00</published><updated>2017-05-06T10:00:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-05-06:/2dxngine-renderowanie-2d-i-inne-informacje.html</id><summary type="html">&lt;p&gt;Cześć wszystkim. Wiem, że ostatnio było mało postów na temat progresu silnika - no niestety stworzenie sensownego renderowania pochłonęło masę czasu na research i implementacje. Mimo tego i tak będę miał sporo refactoringu, ale o tym napiszę później. Podczas implementacji chciałem, aby mój system renderowania był wzorowany na tym co znamy …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć wszystkim. Wiem, że ostatnio było mało postów na temat progresu silnika - no niestety stworzenie sensownego renderowania pochłonęło masę czasu na research i implementacje. Mimo tego i tak będę miał sporo refactoringu, ale o tym napiszę później. Podczas implementacji chciałem, aby mój system renderowania był wzorowany na tym co znamy z Monogame, czyli spritebatchu. Technika ta pozwala na optymalizowane draw call', a dodatkowo opakowana pozwala używać wspomnianego spritebatcha do rysowania 2D oraz dodatkowych metod z graphic device do renderowania 3D. Nie mam jeszcze implementacji graphic device, ale zakładam ją w przyszłości, ponieważ chciałbym, aby silnik potrafił również obsługiwać renderowanie 3D. Jeśli chodzi o spriteach założyłem, że chciałbym go używać w następujący sposób:&lt;/p&gt;
&lt;p&gt;Batch.begin() -&amp;gt; rozpoczynam wkładanie tego co chce renderować do batch
Batch.draw(params) -&amp;gt; odkładanie kolejnych obrazków do batcha
Batch.draw(params) -&amp;gt; odkładanie kolejnych obrazków do batcha
Batch.draw(params) -&amp;gt; odkładanie kolejnych obrazków do batcha
Batch.draw(params)-&amp;gt; odkładanie kolejnych obrazków do batcha
Batch.end() -&amp;gt; rysowanie batcha&lt;/p&gt;
&lt;p&gt;Kto kiedyś używał Monogame lub LibGDX, to na pewno zna powyższy pattern. Ja swojego batcha dodatkowo wzbogaciłem o sampler object(dostępny od OpenGL 3.3) tak, żeby nie trzeba podczas bindowania tekstury ustawiać filtrowania i zawijania tekstury, a można to zrobić przy każdym stracie batchowania. Całość działa całkiem dobrze i dokładnie opiszę wszystko w osobnych artykułach, ponieważ tu nie ma na to miejsca. Dodatkowo zaimplementowałem asset shadera i asset textury2D oraz render target. Ten ostatni będzie służył mi do właściwego renderowania scen, ponieważ standartowo OpenGL renderuje wszytko na back buffer, a mi chodzi żeby rendnerował do tekstury, ponieważ otwiera to możliwości postprocessingu i pozwala mi operować tylko na elementach sceny, a nie na UI. O postporcessingu też pewnie kiedyś napiszę, bo to temat dość ciekawy i mocno przydatny. Co do dalszego rozwoju to jak mam już renderowanie  2D, to mogę zająć się inputem i muzyką a to myślę, że nie będą już tak skomplikowane tematy jak samo ryzowanie. Zanim to jednak nastąpi daje sobie jeszcze tydzień na uporządkowanie kodu i dokończenie renderowania opartego o warstwy. Dodatkowo przydałoby się napisać trochę testów do tego co już zrobiłem, ponieważ nie miałem na to czasu. Myślę, że testy pozwolą mi spojrzeć na całość z nowej pespektywy i nieco zoptymalizować kod, plus sprawdzać czy wszystko działa na pewno tak jak to planowałem. Myślę, że to na razie tyle w przyszłych postach opisze dokładnie poszczególne elementy potrzebne do stworzenie renderowania 2D w OpenGL.&lt;/p&gt;</content><category term="DSP2017"></category><category term="2DXngine"></category></entry><entry><title>Ogólna architektura silnika - sztuczna inteligencja</title><link href="http://localhost:8000/ogolna-architektura-silnika-sztuczna-inteligencja.html" rel="alternate"></link><published>2017-04-22T18:30:00+02:00</published><updated>2017-04-22T18:30:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-04-22:/ogolna-architektura-silnika-sztuczna-inteligencja.html</id><summary type="html">&lt;p&gt;Cześć. W dzisiejszych czasach bardzo popularne są gry sieciowe, więc opierające się o interakcje z innymi graczami. Mimo to sztuczna inteligencja nawet w  nich jest potrzeba, aby tworzyć bossów czy jakieś ciekawe eventy wraz z NPC w świecie gry. W dzisiejszym artykule przyjrzymy się jak stworzyć sztuczną inteligencje na miarę …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć. W dzisiejszych czasach bardzo popularne są gry sieciowe, więc opierające się o interakcje z innymi graczami. Mimo to sztuczna inteligencja nawet w  nich jest potrzeba, aby tworzyć bossów czy jakieś ciekawe eventy wraz z NPC w świecie gry. W dzisiejszym artykule przyjrzymy się jak stworzyć sztuczną inteligencje na miarę naszej gry, tak aby była ona wyzwaniem i spełniała pokładane w niej oczekiwania.&lt;/p&gt;
&lt;p&gt;Chciałem tutaj przejść przez parę podejść do tematu i oprzeć je na paru przykładach. Temat niestety jest szeroki, a i ja nie mam pojęcia o wszystkich możliwych podejściach, więc ograniczę się do tego co w miarę znam - a wy jeżeli znacie jeszcze coś o czym tu nie piszę, to zapraszam jak zawsze do sekcji komentarzy. Nie przedłużając lećmy, więc z tematem.&lt;/p&gt;
&lt;p&gt;SI podejście naiwne&lt;/p&gt;
&lt;p&gt;Zakładając, że piszemy swoją pierwszą grę obiektowo, bez komponent modelu, nasza sztuczna inteligencja dla danego GameObjectu będzie znajdowała się w jego funkcji update. Może to wyglądać w następujący sposób&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;deltaTime&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PlayerIsVisible&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;AttackPlayer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CollideFromLeft&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;MoveRight&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;MoveLeft&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Widzimy mniej więcej do czego takie podejście prowadzi. W pewnym momencie dodając kolejne interakcje metoda update stanie się nieczytelna. Jak już powiedziałem w artykule o GameObjectach na jakiś PoC czy prosty projekt jest to to ok, ale wyobraźmy sobie w taki sposób programować SI dla gry RTS.&lt;/p&gt;
&lt;p&gt;Zaawansowe SI: Planner&lt;/p&gt;
&lt;p&gt;Planner jest jednym z zaawansownych podejść do tworzenia SI w grach. Jako przykład użycia wyobraźmy sobie grę typu city builder (np. Banished). Każemy naszym osadnikom  wybudować dom. Zadanie to może być wykonywanie przez 5 ludzi na raz i potrzeba do niego 20 jednostek drewna i 5 jednostek kamienia. Planner powinien zachować się w następujący sposób:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;przydzielić nam 5 osadników,&lt;/li&gt;
&lt;li&gt;sprawdzić, czy w magazynie mamy 20 jednostek drewna, jeśli nie to wysłać osadników, aby je wytworzyli,&lt;/li&gt;
&lt;li&gt;sprawdzić czy w magazynie mamy 5 jednostek drewna, jeśli nie to wysłać osadników, aby je wytworzyli,&lt;/li&gt;
&lt;li&gt;kazać osadnikom przynieść surowce na miejsce budowy,&lt;/li&gt;
&lt;li&gt;kazać osadnikom wybudować dom,&lt;/li&gt;
&lt;li&gt;po zakończeniu zadania przydzielić osadników do innych prac.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jak możemy zauważyć planer działa w następujący sposób:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Planner" src="/images/si/planner_graph.png"&gt;&lt;/p&gt;
&lt;p&gt;Jest to globalny system zarządzający każdym elementem SI na planszy. Mimo to świetnie sprawdza się w grach strategicznych czy city builderach, pewnie znalazłbym jeszcze inne zastosowanie.&lt;/p&gt;
&lt;p&gt;Zaawansowane SI: Drzewo zachowań&lt;/p&gt;
&lt;p&gt;Jest to bardziej modularne podejście do tematu sztucznej inteligencji. Sama nazwa mówi, że jest to podejście oparte na grafach. Pozwala ono pisać poszczególne zachowania, tworzyć jako osobne klasy, dzięki czemu komponujemy je ze sobą. W drzewie zachowań wyróżniamy następujące elementy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;behavior - są to liście drzewa, które zwierając w sobie ewaluacje i sposób wykonaniu danego zachowania,&lt;/li&gt;
&lt;li&gt;selector - jest to kontener przechowujący zachowania, który podczas ewaluacji wybiera jedno ze swoich dzieci i rozpoczyna jego wykonanie,&lt;/li&gt;
&lt;li&gt;repeater - podobnie jak selektor pełni on role kontenera na zachowania z tym, że włącza on je cyklicznie jedno po drugim.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dla dopełniania tego rozwiązania potrzebne są nam jeszcze 2 elementy evaluator, czyli komponent który sprawdzi czy nasze drzewo jest poprawnie skonstruowane oraz egzekutor, który zajmie się wybraniem i odpaleniem zachowania z drzewa, które jest w danym momencie adekwatne do zaistniałej w świecie gry sytuacji. Przykładowe drzewo może wyglądać w następujący sposób:&lt;/p&gt;
&lt;p&gt;&lt;img alt="BT" src="/images/si/bt_graph.png"&gt;&lt;/p&gt;
&lt;p&gt;Ewaluacja zachowania zaczyna się zawsze od noda "Root" przechodzimy wszerz przez wszytkie kontenery i wybieramy  odpowiednie zachowanie. Istotne jest to, aby dobrze określić warunek wykonania danego zachowania, bądź kontenera tak, aby nie miał on kolizji z innymi elementami drzewa. &lt;/p&gt;
&lt;p&gt;To było by na tyle w tym poście. Piszcie w kometach jakie wy znacie inne podejścia do SI w grach komputerowych.&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category></entry><entry><title>OpenGL a Unit Testy</title><link href="http://localhost:8000/opengl-a-unit-testy.html" rel="alternate"></link><published>2017-04-17T18:00:00+02:00</published><updated>2017-04-17T18:00:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-04-17:/opengl-a-unit-testy.html</id><summary type="html">&lt;p&gt;Cześć. Wiem, że powinienem w pierwszej kolejności napisać o C++ i testowaniu, ale zeszło mi na to jakieś 3 godziny, więc może ktoś skorzysta z mojej wiedzy. Chciałem napisać prosty test sprawdzający czy klasa programu Shadera działa tak jak tego oczekuję. Napisałem więc prosty test, odpaliłem go i od tego …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć. Wiem, że powinienem w pierwszej kolejności napisać o C++ i testowaniu, ale zeszło mi na to jakieś 3 godziny, więc może ktoś skorzysta z mojej wiedzy. Chciałem napisać prosty test sprawdzający czy klasa programu Shadera działa tak jak tego oczekuję. Napisałem więc prosty test, odpaliłem go i od tego  momentu nastąpiła moja mocna konsternacja, która później przerodziła się w nieco większe zdenerwowanie. W projekcie używam GLEW, aby mieć dostęp do funkcji OpenGL i okazuje się, że aby działało kompilowanie shaderów muszę pomyślenie inicjalizować tą bibliotekę, bo inaczej dostane na twarz wyjątek. Po kilu próbach udało mi się pomyślnie skompilować shader w moim głównym projekcie, ale testy wymagały więcej pracy. Musiałem dodać do testów SDL i GLEW dodatkowo testowanie, które wymaga zainicjalizowania okienka i kontekstu OpenGL - robię to za pomocą takiego fixture:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ShaderTestFixture&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;testing&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SetUp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;SDL_Init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SDL_INIT_VIDEO&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;SDL_GL_SetAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SDL_GL_CONTEXT_PROFILE_MASK&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SDL_GL_CONTEXT_PROFILE_CORE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;SDL_GL_SetAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SDL_GL_CONTEXT_MAJOR_VERSION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;SDL_GL_SetAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SDL_GL_CONTEXT_MINOR_VERSION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;SDL_GL_SetAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SDL_GL_DOUBLEBUFFER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;_window&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SDL_CreateWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Game Window&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;SDL_WINDOWPOS_UNDEFINED&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SDL_WINDOWPOS_UNDEFINED&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="mi"&gt;640&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="mi"&gt;360&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;SDL_WINDOW_OPENGL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SDL_GL_CreateContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_window&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;GLenum&lt;/span&gt; &lt;span class="n"&gt;glewError&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;glewInit&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;TearDown&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;SDL_Quit&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sam przykładowy test wygląda tak:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TEST_F&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ShaderTestFixture&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shader_can_be_load_from_inline_source&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//Arrange&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vertexSource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;#version 330 core&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;layout (location = 0) in vec4 position;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;layout (location = 1) in vec4 in_tint;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;out vec2 tex_pos;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;out vec4 tint;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;uniform mat4 projection;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;void main(void)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;{&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;gl_Position = projection * vec4(position.x, position.y, 0.0f, 1.0f);&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;tex_pos = vec2(position.z, position.w);&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;tint = in_tint;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;}&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fragmentSource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;#version 330 core&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;in vec2 tex_pos;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;in vec4 tint;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;out vec4 color;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;uniform sampler2D tex;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;uniform float global_alpha;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;void main(void)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;{&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;color = vec4(tint.x, tint.y, tint.z, global_alpha * tint.w) * texture(tex, tex_pos);&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;shader&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ShaderProgram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertexSource&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fragmentSource&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//Act    &lt;/span&gt;
    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shader&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;//Assert&lt;/span&gt;
    &lt;span class="n"&gt;ASSERT_EQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ShaderCompileResult&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;COMPILATION_SUCESS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dobrze, że ten problem wyszedł teraz, ponieważ mogłem w łatwy sposób zmodyfikować kod. Cała sytuacja nauczyła mnie, żeby pisać testy mimo wszystko, ponieważ jak bym miał zaimplementowane więcej to musiałbym naprawdę mocno się napracować, aby znaleźć źródło problemu. Postaram się napisać inne testy dla elementów używających OpenGL i zobaczymy, czy nie mam większej ilości błędów. Nauka z tej sytuacji jest dość oczywista  - piszemy testy nawet w bardzo ograniczonym zakresie. To na razie tyle mam nadzieję, że komuś przyda się to co w tym miejscu napisałem. Można dodać możliwość konfiguracji wersji OpenGL i inne rzeczy, ale to już później. Mam nadzieję, że w następnym wpisie opisze więcej o testowaniu kodu w C++.&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category><category term="Tools"></category></entry><entry><title>Tworzenie gier w pojedynkę lub małym zespole. Czy to w ogóle możliwe?</title><link href="http://localhost:8000/tworzenie-gier-w-pojedynke-lub-malym-zespole-czy-to-w-ogole-mozliwe.html" rel="alternate"></link><published>2017-04-16T14:15:00+02:00</published><updated>2017-04-16T14:15:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-04-16:/tworzenie-gier-w-pojedynke-lub-malym-zespole-czy-to-w-ogole-mozliwe.html</id><summary type="html">&lt;p&gt;Cześć. W poście o alternatywnych ścieżkach rozwoju w programowaniu opowiedziałem nieco jak ja się rozwijam jako programista. Teraz chciałem opowiedzieć o implementacji takiego modelu rozwoju w prawdziwym życiu. Tworzenie gier to bardzo fajne ciekawe i mega rozwijające hobby. Oprócz programowania trzeba poznać nieco matematyki, fizyki, architektury komputera, wzorców projektowych, tworzenia …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć. W poście o alternatywnych ścieżkach rozwoju w programowaniu opowiedziałem nieco jak ja się rozwijam jako programista. Teraz chciałem opowiedzieć o implementacji takiego modelu rozwoju w prawdziwym życiu. Tworzenie gier to bardzo fajne ciekawe i mega rozwijające hobby. Oprócz programowania trzeba poznać nieco matematyki, fizyki, architektury komputera, wzorców projektowych, tworzenia grafiki, programowania grafiki, itp. Już chyba każdy widzi dokąd to zmierza - na gry trzeba mieć masę czasu szczególnie, jeśli robimy je w zakresie hobbystycznym, po godzinach w małym zespole lub samemu - jeżeli jeszcze po ostatnim zdaniu nie zrezygnowałeś i czytasz dalej to powiem Ci, że mimo tego można stworzyć samemu grę i jest na to dość sporo przykładów. Dla mnie koronnym przykładem jest Sos i jego McPixel, oczywiście miał trochę szczęścia, ale i jego produkt jest na dobrym poziomie - jeżeli jesteś na początku swej drogi i nie masz z grami doświadczeniami powiem Ci tyle, że nie licz, iż pierwszą grę uda Ci się w ogóle skończyć. Ja swój pierwszy prototyp wyrzuciłem do kosza po 3 miesiącach developmentu. Mimo to dalej mam go na repozytorium i korzystam z jego kilku rozwiązań. Dlatego polecam na początek stworzyć cokolwiek, co można nazwać grą. Lubisz platformówki zrób ją, lubisz gry logiczne zrób grę logiczną - to naprawdę nie ma znaczenia. Pierwsza gra pozwoli Ci na zapoznanie się z wybraną przez siebie biblioteką lub framwerokeim, stworzyć pierwszy mały engine w końcu pozwoli uczyć Ci się na błędach no i oczywiści co ważne dołączyć do ludzi piszących na twitterze posty z #gamedev. Twitter to w ogóle świetne narzędzie dla ludzi kreatywnych, ale o tym to chyba inny post napiszę. Kolejnym etapem, który warto poczynić po pierwszym prototypie jest konceptualizacja. Ja swoje gry zaczynałem tworzyć w następujący sposób: grałem w jakiś typ gry, chciałem zrobić coś podobnego, bo w tym co ogrywałem czegoś brakowało, zaczynałem pisać, na pewnym etapie brakowało mi pomysłów, więc doklejałem wszystko co mogłem, porzucałem projekt, bo trzeba by było go zacząć robić od początku ze względu na błędy w kodowaniu i designie.
Tak wygląda droga, ale należy pamiętać, że każdy z tych projektów mnie czegoś uczył i pozwalał na więcej. Obecnie pracuje znowu nad kolejną grą, ale zacząłem od nieco innej strony. W ramach DSP2017 mam nadzieje stworzyć podwaliny własnego silnika 2d. Jednocześnie konceptualizacje grę, co oznacza, że siedzę z kartka papieru i ogarniam o czym ta gra powinna być, projektuję fabułę, postaci, poziomy tak, aby stworzyć sobie zamknięty obraz całości. Wiadomo, że gra będzie się zmieniała z czasem, ale już teraz widzę, że taki plan sporo mi ułatwi, ponieważ nie będę musiał wymyślać na poczekaniu tego co chcę zrobić, tylko będę miał jakąś mniej lub bardziej określoną listę rzeczy do zrobienia. Jednym z największych problemów programisty robiącego gry jest grafika. Polecam w takim wypadku nauczyć się chociaż jakiegoś prostego pixelartu. Jeżeli nasza gra będzie popularna to na pewno grafika nie będzie najważniejsza -&amp;gt; patrz McPixel. Tak jak napisałem istotny jest tech i plan, jeżeli mamy to powinniśmy nasza grę napisać na tyle, aby posiadał ona bazowy gameplay. Jak już to będziemy mieli, to należy zebrać feedback od użytkowników. Jest to bardzo ważny proces w którym pomogą nam takie serwisy jak IndieDb czy itch.io. W tak zwanym międzyczasie powinniśmy grę reklamować w social mediach. Weźmy pod uwagę, że na początku cała ta machina będzie rozpędzać się raczej wolno, mimo to uważam, że jeżeli będziemy konsekwentni w swoich działaniach, to powinno się udać. Ważne jest to, aby nie myśleć, że nasza pierwsza gra (ta ukończona) będzie kolejnym Minecraftem, bo ta gra była jedyna i na pewno my tyle nie zarobimy o ile w ogóle coś zarobimy. Ogóle takie myślenie, że zrobię grę czy cokolwiek i od jutra będę milionerem jest złe. Każdy biznes rozkręca się powoli, a w grach najważniejsze jest zbudowanie sobie community, które będzie w naszą grę grało. Inną sprawą jest praca dla przyjemności. Dla mnie właśnie takie jest tworzenie gier. Robię to, bo to lubię i jak na razie nie zamierzam przestać. To chyba na tyle w tym poście, jeżeli macie jakieś swoje pomysły jak tworzyć grę w małych zespołach lub samemu i nie zwariować to zapraszam do sekcji komentarzy.&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category></entry><entry><title>Ogólna architektura silnika - component model</title><link href="http://localhost:8000/ogolna-architektura-silnika-component-model.html" rel="alternate"></link><published>2017-04-11T18:20:00+02:00</published><updated>2017-04-11T18:20:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-04-11:/ogolna-architektura-silnika-component-model.html</id><summary type="html">&lt;p&gt;Poprzedni post z tego cyklu traktował o tym jak tworzyć GameObjecty za pomocą hierarchii dziedziczenia. Jak już pisałem sposób ten staje się nieczytelny, w miarę rozwoju projektu, ale pozwala szybko wystartować. Dla większych gier GameObjecty tworzymy w nieco inny sposób używając nie dziedziczenia, a kompozycji stąd nazwa component model. W …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Poprzedni post z tego cyklu traktował o tym jak tworzyć GameObjecty za pomocą hierarchii dziedziczenia. Jak już pisałem sposób ten staje się nieczytelny, w miarę rozwoju projektu, ale pozwala szybko wystartować. Dla większych gier GameObjecty tworzymy w nieco inny sposób używając nie dziedziczenia, a kompozycji stąd nazwa component model. W tej implementacji GameObject sam z siebie jest tylko agregatorem dla komponentów. To one nadają mu właściwe funkcjonalności. Przykładowo  jak do obiektu dodamy komponenty:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tekstura z animacjami nietoperza,&lt;/li&gt;
&lt;li&gt;odtwarzacz animacji poklatkowych,&lt;/li&gt;
&lt;li&gt;kontroler sztucznej inteligencji,&lt;/li&gt;
&lt;li&gt;drzewo zachowań dla SI latających.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tak otrzymamy nietoperza, który będzie latał zgodnie z konfiguracją SI. Już na pierwszy rzut oka widać, że component model daje możliwości pewnej separacji i ponownego użycia raz napisanej logiki GameObjectów - jeżeli zrobimy logikę podążania za graczem, to może jej używać kilka obiektów na scenie itp. Jak już wiemy jak to mniej więcej ma wyglądać teoretycznie to przyjrzymy się jakie elementy są potrzebne, aby wygodnie się tak skonstruowanym systemem GameObjectów posługiwać. Ja zawsze implementuję takie elementy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GameObjectManager - Manager posiada wszystkie GameObjecty na scenie, można się do niego odwołać ze samej sceny, podsystemów sceny, i gameobjectów. Jest to obiekt zarządzający całą hierarchią, można za jego pomocą dodawać, wyszukiwać i usuwać obiekty, &lt;/li&gt;
&lt;li&gt;GameObject - w tym podejściu jest on jedynie kontenerem na komponenty i nie wykonuje sam żadnej logiki. Można za jego pomocą dodawać, usuwać i wyszukiwać komponenty oraz dodawać nowe gameobjecty jako dzieci. Celowo napisałem również, że nie wykonuje on żadnej logiki. Ja w swoich implementacjach stosuje update serivce i draw service, który ma listę komponentów do aktualizacji i rysowania. W razie jakiś zmian komponenty są na nowo zbierane ze wszystkich gameobjectów. Jest to bardziej optymalne od strony wykonania i zgodne z zasadami Data-Oriented Design.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jeśli chodzi o komponenty to je również dziele na grupy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Behaviors - komponenty aktualizowane co klatkę, może to by np. kontroler postaci czy kontroler sztucznej inteligencji,&lt;/li&gt;
&lt;li&gt;Drawables - komponenty graficzne, które będą rysowane co klatkę, np. sprite'y, animacje, efekty,&lt;/li&gt;
&lt;li&gt;DataComponents - komponenty przechowujące dane, do których odwołują się inne komponenty, np. komponent przechowujący informacje o położeniu gameobjetu na scenie.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jako, że komponenty mogą korzystać z innych komponentów w ramach jednego gameobjectu lub hierarchii rodzic - dziecko, należy zaimplementować jakiś system rozwiązywania zależności przy inicjalizacji komponentu. Można to zależnie od języka programowania zaimplementować na kilka sposobów. 
Component model jest, więc dość złożoną, ale jednocześnie skalowalną implementacją struktury sceny. Pracowałem z jego pomocą nad paroma produkcjami. W razie jakichś niejasności lub pytań zapraszam do komentowania.&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category></entry><entry><title>2DXngine podsumowanie pierwszego miesiąca pracy</title><link href="http://localhost:8000/2dxngine-podsumowanie-pierwszego-miesiaca-pracy.html" rel="alternate"></link><published>2017-04-08T20:40:00+02:00</published><updated>2017-04-08T20:40:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-04-08:/2dxngine-podsumowanie-pierwszego-miesiaca-pracy.html</id><summary type="html">&lt;p&gt;Cześć, dawno nic nie pisałem na temat projektu, ale nie oznacza to, że nic w tym temacie się nie dzieje. Mam parę problemów natury filozoficznej przy podejmowaniu kilku decyzji, ale o tym może później. Zacznijmy od tego co udało się zrobić, co jest w trakcie realizacji. Z rzeczy zrealizowanych należało …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć, dawno nic nie pisałem na temat projektu, ale nie oznacza to, że nic w tym temacie się nie dzieje. Mam parę problemów natury filozoficznej przy podejmowaniu kilku decyzji, ale o tym może później. Zacznijmy od tego co udało się zrobić, co jest w trakcie realizacji. Z rzeczy zrealizowanych należało by wymienić:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system rozpoznawania typów,&lt;/li&gt;
&lt;li&gt;system GameObjectów,&lt;/li&gt;
&lt;li&gt;component model,&lt;/li&gt;
&lt;li&gt;eventy,&lt;/li&gt;
&lt;li&gt;system scen.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Właściwie do wszystkiego mam też napisane testy. Jedynie pominąłem system scen ze względu na to, że nie wiem jeszcze czy po implementacji renderera i zarządzania assetami nie będę musiał wykonać w nim jakiś większych zmian. Zmieniłem teraz też podejście do tego co chcę zrobić. Po pierwsze chciałbym mieć do końca tego miesiąca proof of concpet, który jest działający, czyli mogę dodać do sceny game object i wyrenderować go, poruszać nim i w ogóle. Wiem, że to nie cały silnik, ale pozwoli mi to zboczyć czy idę w dobrym kierunku. Po zakończeniu tego etapu dopisze testy dla sceny i elementów nie Open GL'owych. 
W obecnym momencie skupiam, się więc nad następującymi rzeczami :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wczytywaniem tekstur,&lt;/li&gt;
&lt;li&gt;zarządzaniem assetami,&lt;/li&gt;
&lt;li&gt;renderowaniem 2d&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Każdą z tych rzeczy mam mocno rozgrzebaną, dodatkowo jeżeli chodzi o renderowanie jak już pisałem mam pewne problemy, co do wyboru technologii. Open GL jest już na rynku parę lat i jest co powoduje, że różnych materiałów na jego temat jest sporo. Z drugiej strony mamy nowe api czyli Vulcan'a, które jak już napisałem jest nowe co powoduje, że mniej na jego temat informacji. Bardzo dużo czasu zajął mi więc wybór pomiędzy tymi bibliotekami, jednak ostatecznie uznałem, że użyje Open GL z tym, że postaram się go na tyle opakować w swoje klasy, żeby w momencie kiedy będę gotowy przejść na Vulcana, to to zrobię bez zmiany api w samym silniku lub niewielkimi zmianami. Zobaczymy oczywiście jak to wyjdzie. 
Kolejną sprawą do której się przymierzam to wielowątkowości. W obecnym momencie silnik działa w jednym wątku, ale czytam na ten temat, więc myślę, że za jakiś czas spróbuje coś zadziałać, aby jakieś elementy działały w osobnych wątkach.&lt;br&gt;
To na razie na tyle zobaczymy co przeniesie ten miesiąc i na ile uda mi się zrobić to co chciałbym, aby było skończone.&lt;/p&gt;</content><category term="DSP2017"></category><category term="2DXngine"></category></entry><entry><title>Eventy jak w C# w C++</title><link href="http://localhost:8000/eventy-jak-w-c-w-c.html" rel="alternate"></link><published>2017-03-31T21:00:00+02:00</published><updated>2017-03-31T21:00:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-03-31:/eventy-jak-w-c-w-c.html</id><summary type="html">&lt;p&gt;Cześć.
Niestety w tym tygodniu nie miałem czasu za dużo popracować nad silnikiem. Co prawda pisze system scen, ale mam to tak rozgrzebane, że nie jestem w stanie tego podsumować. Mimo tego udało mi się zrobić jedną fajną rzecz, którą chciałem się z wami podzielić. Implementując silnik pomyślałem, że będę …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć.
Niestety w tym tygodniu nie miałem czasu za dużo popracować nad silnikiem. Co prawda pisze system scen, ale mam to tak rozgrzebane, że nie jestem w stanie tego podsumować. Mimo tego udało mi się zrobić jedną fajną rzecz, którą chciałem się z wami podzielić. Implementując silnik pomyślałem, że będę od czasu do czasu musiał powiadamiać pewne elementy sceny o tym, że np. GameObject zyskał nowy komponent czy childa lub coś innego się wydarzyło się, co ma jakieś znaczenie dla innych GameObjectów czy logiki gry. Początkowo chciałem zaimplementwotać EventBus'a, wiecie taki statyczny z subscriberami i publisherami, ale pomyślałem tak skoro udało mi się zaimplementować system typów to może uda się przenieść do C++ eventy podobne do tych C#. Myśląc niedługo zdecydowałem się spróbować a oto efekty pracy.  Na potrzeby rozwiązania zaimplementowałem Event handler nie parametryzowany i nie parametryzowany, binding funkcji handlującej dany event, oraz makra pozwalające w łatwy sposób tworzyć binding. Jako, że kod jest na githubie a dokładnie (TU)[https://github.com/Harunx9/2DXngine/tree/master/2DXngine.Core/src/Utils/Events] nie będę osobno omawiał handlerów tylko pokaże jak działa całość na podstawie jednego z nich. W całej implementacji chodziło mi o coś takiego jak mamy w C#, czyli :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;someObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SomeEvent&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;HandlerFunction&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//przypinanie eventu&lt;/span&gt;
&lt;span class="n"&gt;someObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SomeEvent&lt;/span&gt; &lt;span class="p"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;HandlerFunction&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//odpinanie eventu&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Co prawda mój system jest pewnie dużo prostszy, ale w sumie działa podobnie mimo paru ograniczeń. Przykładowy handler wygląda tak:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;EventHandler&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;EventHandler&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Binding&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;EventArgs&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;binding&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;_subscribers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;binding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_code&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;binding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;EventHandler&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Binding&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;EventArgs&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;binding&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;_subscribers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;binding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_code&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;isUsed&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;_subscribers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;invoke&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EventArgs&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_subscribers&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nl"&gt;subscriber&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;subscriber&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="n"&gt;EventArgs&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;invoke&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;get_nextID&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;_curretnId&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;_curretnId&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EventArgs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;_subscribers&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Całość jak widać udało mi się zrobić nadpisując operatory : +=. -= oraz (). Jest to wielka siłą C++ ale jak wiemy "with great power comes great responsibility", więc nie polecam stosować nadpisania operatorów do każdego problemu. Dodatkowo ze względu na to, żeby wygodniej usuwało się subskrybentów zaimplementowałem statyczne generowanie kolejnych id dla bindingów, tak aby były one w miarę unikalne, a jednocześnie myślę, że nikt wartości int nie przekroczy, jeżeli będzie chciał korzystać z tego silnika. Aby taka sytuacja nastąpiła musiał by ktoś na prawdę nadużywać eventów. Aby można było dodawać eventy stworzyłem oto taką strukturę: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;TEventArgs&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Binding&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Binding&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="n"&gt;Binding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TEventArgs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;get_code&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TEventArgs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;get_func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;_code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TEventArgs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;_func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Enkapsuluje ona id bindingu oraz wskaźnik na funkcje. Z mojej wiedzy wynika, że std::function to nowy typ dostępny od C++11(na studiach uczyłem sie C++98, więc dla mnie jest to nowość), więc zobaczymy jak się sprawdzi jak na razie w testach wygląda dobrze, więc mam nadzieje, że nie będzie z nią problemów wydajnościowych.
Do tego dodałem jeszcze 2 makra automatyzujące tworzenie bindingów. I to tyle implementacji, jeżeli ktoś chce zobaczyć przykłady użycia to znajdują się one w unit testach. Mam nadzieję że taka implementacja się sprawdzi. Jak skończę implementacje GameObject' u wraz ze zdarzeniami zmian jego struktury to dam wam znać. Jeżeli ktoś ma jakieś pomysły, rady, opinie to jak zawsze zapraszam do sekcji komentarzy.&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category><category term="Tools"></category></entry><entry><title>Własny TypeInfo w C++</title><link href="http://localhost:8000/wlasny-typeinfo-w-c.html" rel="alternate"></link><published>2017-03-27T19:10:00+02:00</published><updated>2017-03-27T19:10:00+02:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-03-27:/wlasny-typeinfo-w-c.html</id><summary type="html">&lt;p&gt;Cześć, dziś chciałem pokazać jak zrobiłem system informacji o typach obiektów w silniku 2DXngine, który powstaje w ramach konkursu "Daj się poznać". Taki feature był mi porzebny do wysukiwania po typie komponentów z GameObjectu. Nie chciałem używać standardowego  TypeId, ponieważ mądrzejsi ode mnie mówią, że jest to powolne, i że …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć, dziś chciałem pokazać jak zrobiłem system informacji o typach obiektów w silniku 2DXngine, który powstaje w ramach konkursu "Daj się poznać". Taki feature był mi porzebny do wysukiwania po typie komponentów z GameObjectu. Nie chciałem używać standardowego  TypeId, ponieważ mądrzejsi ode mnie mówią, że jest to powolne, i że refleksja w  runtime jest ogólnie zła. Dlatego należy pomyśleć tak, aby jak najwięcej zrobić w compile time. Tak jak już wiecie dopiero uczę się C++, więc przejrzałem trochę Internet i w moim rozwiązaniu mocno inspirowałem się &lt;a href="http://www.axelmenzel.de/articles/rtti"&gt;TYM&lt;/a&gt; artykułem. Podobnie jak w nim moje rozwiązanie opiera się na makrach i TypeCache, ale po kolei. Aby zarejestrować typ używam takich oto makr:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define DECLARE_TYPE_INFO(Type, BaseType)                                            \&lt;/span&gt;
&lt;span class="cp"&gt;                                                                                     \&lt;/span&gt;
&lt;span class="cp"&gt;template&amp;lt;&amp;gt;                                                                           \&lt;/span&gt;
&lt;span class="cp"&gt;struct TypeIdInfo&amp;lt;Type&amp;gt;                                                              \&lt;/span&gt;
&lt;span class="cp"&gt;{                                                                                    \&lt;/span&gt;
&lt;span class="cp"&gt;    static TypeInfo getType()                                                        \&lt;/span&gt;
&lt;span class="cp"&gt;    {                                                                                \&lt;/span&gt;
&lt;span class="cp"&gt;        static const TypeInfo typeInfo = getOrRegisterTypeInChache(#Type, #BaseType);\&lt;/span&gt;
&lt;span class="cp"&gt;        return typeInfo;                                                             \&lt;/span&gt;
&lt;span class="cp"&gt;    }                                                                                \&lt;/span&gt;
&lt;span class="cp"&gt;};                                                                                   \&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To makro dodaję w plikach .h., jeżeli nie ma bazowego typu zostawiam "" . Będę musiał to przemyśleć w przyszłości, na razie to rozwiązanie mi nie przeszkadza.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define DEFINE_TYPE_INFO(Type)                                 \&lt;/span&gt;
&lt;span class="cp"&gt;                                                               \&lt;/span&gt;
&lt;span class="cp"&gt;template&amp;lt;&amp;gt;                                                     \&lt;/span&gt;
&lt;span class="cp"&gt;struct RegisterType&amp;lt;Type&amp;gt;                                      \&lt;/span&gt;
&lt;span class="cp"&gt;{                                                              \&lt;/span&gt;
&lt;span class="cp"&gt;    RegisterType()                                             \&lt;/span&gt;
&lt;span class="cp"&gt;    {                                                          \&lt;/span&gt;
&lt;span class="cp"&gt;        TypeIdInfo&amp;lt;Type&amp;gt;::getType();                           \&lt;/span&gt;
&lt;span class="cp"&gt;    }                                                          \&lt;/span&gt;
&lt;span class="cp"&gt;};                                                             \&lt;/span&gt;
&lt;span class="cp"&gt;static const RegisterType&amp;lt;Type&amp;gt; CAT(registerType, __COUNTER__);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Powyższe makro oddaje w plikach .cpp, żeby rejestracja nastąpiła automatycznie. Wykorzystany jest tu pewien trik, a mianowicie jeśeli zdefiniujemy generyczna statyczny const, to zostanie on wywołany przed funkcją main, co daje nam therad safe przy rejestracji naszych obiektów.
Funkcja rejestrująca wygląda w następujący sposób:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TypeInfo&lt;/span&gt; &lt;span class="nf"&gt;getOrRegisterTypeInChache&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;parentTypeName&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TypeInfo&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;typeCache&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TypeCache&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get_instance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;typeCache&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;get_typeAlreadyExist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TypeCache&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get_nextId&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;paretnId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parentTypeName&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;TypeInfo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;parentType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;typeCache&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;get_typeByRef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parentTypeName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parentType&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;paretnId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parentType&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;get_id&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TypeInfo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;paretnId&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;typeCache&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;addType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;typeCache&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;get_typeByValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;W skrócie zagląda ona do TypeCache, czy dany typ jest już tam zarejestrowany i jeżeli jest to go zwraca, a jeżeli nie to tworzy nowy. W 99 procentach przypadków będzie nam oddawała już wygenerowany TypeId, ponieważ jak już napisałem rejestracja odbywa się automatycznie przed funkcją main. Ze względu na to, że całość kodu jest na githubie nie będę dokładnie omawiał implementacji TypeCache i TypeInfo, jeżeli kotś jest ciekawy to zapraszam &lt;a href="https://github.com/Harunx9/2DXngine/tree/master/2DXngine.Core/src/TypeInformation"&gt;TU&lt;/a&gt;. Zaimplementowany system informacji o typie pozwala mi na to, że mogę w łatwy sposób wyszukiwać instancji obiektów ,które reprezentują daną klasę, ale i wyszukiwać prze klasy bazowe. Przykładowo może poszukać wszystkich komponentów dziedziczących po UpdateableComponents. System ten ma niestety jedno ograniczenie a mianowicie, aby dawał on informacje deterministyczne obiekty mogą dziedziczyć tylko i wyłącznie po jednej klasie bazowej. Oczywiście można by go bardziej rozwinąć tak, aby wprowadzić interfejsy czy wielodziedziczenie, ale na razie nie widzę takie potrzeby, ponieważ z założenia hierarchia dziedziczenia komponentów jest raczej dość liniowa, więc myślę, że na potrzeby silnika rozwiązanie jest wystarczające. Pozostaje jeszcze kwestia optymalizacji ale to, że tak powiem wyjdzie podczas implementacji gry na silniku, więc na razie nie jestem w stanie sprawdzić jak mocno takie otrzymywanie informacji o typie spowolni wykonywanie logiki gry. To chyba na tyle, jeżeli chodzi o moje podejście to systemu informacji o typach. Jeżeli macie jakieś pytania czy uwagi to zapraszam do sekcji komentarzy.&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category><category term="C++"></category></entry><entry><title>2DXngine: aktualizacja po trzecim tygodniu</title><link href="http://localhost:8000/2dxngine-aktualizacja-po-trzecim-tygodniu.html" rel="alternate"></link><published>2017-03-25T10:00:00+01:00</published><updated>2017-03-25T10:00:00+01:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-03-25:/2dxngine-aktualizacja-po-trzecim-tygodniu.html</id><summary type="html">&lt;p&gt;Witam W tym tygodniu udało mi się po pierwsze popracować trochę więcej. Jak policzę tak to mniej więcej to wyszło około 24 godziny. Nie było też już większych problemów implementacyjnych.&lt;/p&gt;
&lt;p&gt;W ciągu tego tygodnia udało mi się zrobić do końca GameObject - właściwie całość jest  już działająca. Testy również w większości …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Witam W tym tygodniu udało mi się po pierwsze popracować trochę więcej. Jak policzę tak to mniej więcej to wyszło około 24 godziny. Nie było też już większych problemów implementacyjnych.&lt;/p&gt;
&lt;p&gt;W ciągu tego tygodnia udało mi się zrobić do końca GameObject - właściwie całość jest  już działająca. Testy również w większości są napisane, oczywiście ta klasa będzie rozwijana w miarę potrzeb, ale na razie wydaje mi się, że spełnia ona swoje założenia funkcjonalne. Drugą rzeczą, którą udało mi się skończyć to GameObjectManager jeszcze musze do niej dopisać testy co pewnie uczynię w najbliższym czasie, więc pewnie wyjdą jakieś błędy implementacyjne. Dodatkowo stworzyłem początkową strukturę klas dla systemu scen, czyli scenę abstrakcyjną i manager scen. Myślę, że teraz właśnie te elementy systemu będę rozwijał. &lt;/p&gt;
&lt;p&gt;Przydałoby się też rozpocząć manager assetów i renderer, więc nie wiem czy nie zrównoleglę prac, bo chciałbym żeby wreszcie coś zaczęło się wyświetlać, ponieważ na razie jedyne co się wyświetla to zielone kropki przy testach jednostkowych. To żeby jak największa cześć silnika była przetestowana to jednak dla mnie priorytet jak już pisałem zresztą. Implementacja pójdzie przez to wolniej, ale potencjalnie będzie mniej problemów później. Staram, się tez trzymać TDD, ale często mam prace, które wymagają ode mnie stworzenia api bez wiedzy jak ono ma wyglądać co utrudnia TDD,  ale myślę, że jeszcze trochę praktyki i może uda mi się tak wytwarzać kodzik. &lt;/p&gt;
&lt;p&gt;Z rzeczy związanych z silnikiem to powstaje już artykuł o tym rozpoznawaniu i porównywaniu typów w C++, ale jeszcze potrzebne są ostatnie szlify, aby wszedł na bloga więc myślę, że po weekendzie się pojawi na blogu. To chyba tyle, widzę że jest tego mało, ale niestety ostanie implementacje nie są niczym ciekawym. W C++ nie mam LINQ i większość mojego czasu pochłaniają implementacje wyszukiwania dodawania i usuwania w kolekcjach C++, no niestety taka specyfika języka i projektu.  Myślę, że jak dojdziemy do renderowania i zarządzania assetami to będę miał więcej ciekawych rzeczy do napisania. Tymczasem trzymajcie się do następnego update'u.&lt;/p&gt;</content><category term="DSP2017"></category><category term="2DXngine"></category></entry><entry><title>Ogólna architektura silnika - system Encji/GameObject'ów</title><link href="http://localhost:8000/ogolna-architektura-silnika-system-encjigameobjectow.html" rel="alternate"></link><published>2017-03-21T18:20:00+01:00</published><updated>2017-03-21T18:20:00+01:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-03-21:/ogolna-architektura-silnika-system-encjigameobjectow.html</id><summary type="html">&lt;p&gt;Ostatni post tego cyklu był o zarządzaniu scenami, dziś postaram się nieco napisać o tym co powinno być na scenie, aby gra posiadała jakiś gameplay. Mowa tu będzie o Aktorach, Encjach lub GameObjetach w zależności od biblioteki/engine'u nazwa może się różnić, ale to ciągle to samo. Takim elementem może …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Ostatni post tego cyklu był o zarządzaniu scenami, dziś postaram się nieco napisać o tym co powinno być na scenie, aby gra posiadała jakiś gameplay. Mowa tu będzie o Aktorach, Encjach lub GameObjetach w zależności od biblioteki/engine'u nazwa może się różnić, ale to ciągle to samo. Takim elementem może być na scenie wszystko, od postaci gracza do przeciwników, przedmiotów do zbierania itp.  Istnieją dwie drogi do implementacji GameObject'ów w tym artykule opiszę drogę z dziedziczeniem, natomiast component model będzie opisany oddzielnie. &lt;/p&gt;
&lt;p&gt;Droga implementacji za pomocą dziedziczenia wygląda w następujący sposób:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tworzymy abstrakcję, która powinna zawierać: pozycję, nazwę , wysokość, szerokość ; jeżeli nie korzystamy z biblioteki fizycznej to należy tu również zdefiniować zmienne potrzebne do jej obsługi. Dodatkowo obiekt powinien zawierać abstrakcje dla aktualizacji oraz rysowania obiektu,&lt;/li&gt;
&lt;li&gt;tworzymy kolejno obiekty dziedzicząc z bazowego,&lt;/li&gt;
&lt;li&gt;w momencie kiedy zauważamy, że dane obiekty mają ze sobą jakieś cechy wspólne tworzymy dla nich wspólną abstrakcje.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Na tak może wyglądać przykładowa hierarchia:&lt;/p&gt;
&lt;p&gt;&lt;img alt="GameObjects" src="/images/go_graph.png"&gt;&lt;/p&gt;
&lt;p&gt;Takie podejście ma swoje plusy i minusy. Zacznijmy od tego co uważam za pozytywne strony takiej implementacji. Po pierwsze pozwala ona szybko wystartować, ponieważ na początku nie mamy skonceptualizowanego całego gameplay'u, chcemy np. zrobić platformówkę to pomoże nam to zrobić prototyp w parę dni. Jeżeli projekt jest mały to również to podejście się sprawdzi, ponieważ nie będzie miał on dużej ilości elementów. Problem tego podejścia zaczyna się kiedy gra zaczyna rosnąć, ponieważ każdy nowy GameObject wymaga nowej klasy a każda kategoria GameObject'ów dodatkowej abstrakcji. Prowadzi to do bardzo dużej ilości plików oraz skomplikowanej i nieraz wielopoziomowej hierarchii dziedziczenia. Taki kod staje się trudny do utrzymania. Dodatkowo testowanie tak stworzonych encji jest prawie niemożliwe. Poza tym problematyczne staje się dodawanie nowych funkcji go istniejących GameObject'ów, gdy chcemy coś dodać musimy modyfikować istniejący kod, co w efekcie może prowadzić do zepsucia już działających funkcji. 
Mimo tego co napisałem polecam to podejście, jeżeli zaczynasz swoją przygodę z grami. Pozwoli Ci to jak już pisałem szybko wystartować i szybko pokazać prototyp innym ludziom, co jest bardzo istotne pod względem zbierania feedbacku na temat gry. Jeśli jednak wasza gra stanie się większa powinniście iść w stronę component modelu, który opisze w następnym poście.&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category></entry><entry><title>2DXngine: aktualizacja po drugim tygodniu</title><link href="http://localhost:8000/2dxngine-aktualizacja-po-drugim-tygodniu.html" rel="alternate"></link><published>2017-03-17T21:40:00+01:00</published><updated>2017-03-17T21:40:00+01:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-03-17:/2dxngine-aktualizacja-po-drugim-tygodniu.html</id><summary type="html">&lt;p&gt;Cześć. Mija drugi tydzień konkursu "Daj się poznać " pora więc na podsumowanie tygodnia prac nad projektem 2DXngine. Niestety z braku czasu w tym tygodniu prace nieco spowolniły, ale mimo to udało się skończyć mi prace nad systemem typów, ale po kolei. W tym tygodniu znowu średnio szło mi ze śledzeniem …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć. Mija drugi tydzień konkursu "Daj się poznać " pora więc na podsumowanie tygodnia prac nad projektem 2DXngine. Niestety z braku czasu w tym tygodniu prace nieco spowolniły, ale mimo to udało się skończyć mi prace nad systemem typów, ale po kolei. W tym tygodniu znowu średnio szło mi ze śledzeniem swojego czasu pracy, ale mogę powiedzieć, że spędziłem nad projektem około 14 godzin. Nie cały ten czas poszedł jednak na development, ponieważ musiałem mocno się douczyć. Po pierwsze zderzyłem się z makrami do tej pory nie musiałem ich nigdy używać a i też w książkach, które czytałem opisy co można z nimi zrobić były dość lakoniczne. Po drugie kiedy już myślałem, że wszystko elegancko działa nagle okazało się, że jeszcze parę rzeczy muszę doimplementować. Dobra koniec narzekania przejdźmy do tego co udało mi się zrobić. Aby prawu cytatu stało się za dość a i kudosy za ułatwienie mi pracy poszły w odpowiednie miejsce to implementację swojego rozwiązanie oparłem o pewien artykuł który znajdziecie &lt;a href="http://www.axelmenzel.de/articles/rtti"&gt;TU&lt;/a&gt;. Na potrzeby component modelu zaimplementowałem prosty system rozpoznawania typów - pozwala on wyciągnąć z zarejesrtowanych klas typ za pomocą metody getType. Typ posiada swój identyfikator i nazwę oraz identyfikator typu bazowego (w przypadku kiedy go nie ma jest to wartość -1). Niestety postawiłem pewne ograniczenia, a mianowicie nie można dziedziczyć po więcej niż jednej klasie, można natomiast dziedziczyć dowolnie głęboko, ponieważ typ posiada możliwość sprawdzenia czy w jego bazowych typach nie znajdują się typy wyższe pozwala to np. wyszukać wszystkie komponenty dziedziczące po jakieś wspólnej abstrakcji. 
Oprócz klasy reprezentującej typ na rozwiązania składają się następujące elementy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeCache - elementy agregujący wszystkie typu korzystają z niego inne elementy dodając lub pobierając informacje o typie ,&lt;/li&gt;
&lt;li&gt;makro definiujące i deklarujące typ - służą one do rejestracji, a dzięki zastosowaniu sztuczki ze statycznym wywołaniem klasy rejestracyjnej wywołują się przed funkcją main, co czyni to rozwiązanie bezpieczne dla wielowątkowości i w miarę zautomatyzowane,&lt;/li&gt;
&lt;li&gt;macro dodające do klasy funkcje getType, dzięki której jesteśmy w stanie pobrać typ z instancji klasy.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dokładnie z przykładami kodu postaram opisać się to rozwiązanie w przyszłych postach. Całość jest już na GitHubie, więc jeżeli ktoś jest ciekawy to zapraszam do zapoznania się z kodzikiem. Jeżeli ktoś z czytających mnie osób zajmuje się  C++ i ma do polecenia jakieś ciekawe książki to zapraszam do sekcji komentarzy. Tymczasem w tym tygodniu planuje dalej rozwijać GameObject i komponenty, może uda mi się zacząć coś ze scenami. Pierwszą sprawą jest jednak to abym dopisał więcej testów do istniejących funkcjonalności, więc tym zajmę się w najbliższych dniach.&lt;/p&gt;</content><category term="DSP2017"></category><category term="2DXngine"></category></entry><entry><title>Narzędzia przydatne w tworzeniu gier</title><link href="http://localhost:8000/narzedzia-przydatne-w-tworzeniu-gier.html" rel="alternate"></link><published>2017-03-15T20:00:00+01:00</published><updated>2017-03-15T20:00:00+01:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-03-15:/narzedzia-przydatne-w-tworzeniu-gier.html</id><summary type="html">&lt;p&gt;Jako, że słowo się rzekło, teraz więcej postów o tematyce związanej z szeroko pojętym gamedevem. Dziś chciałbym przybliżyć wam kilka fajnych narzędzi, które można wykorzystać tworząc własny silnik do gry.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.mapeditor.org/"&gt;Tiled&lt;/a&gt; - Darmowy&lt;/p&gt;
&lt;p&gt;Ze wszystkich programów z Tiled korzystam chyba najwięcej. Jest to prosty i intuicyjny edytor poziomów do gier.  Mimo …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Jako, że słowo się rzekło, teraz więcej postów o tematyce związanej z szeroko pojętym gamedevem. Dziś chciałbym przybliżyć wam kilka fajnych narzędzi, które można wykorzystać tworząc własny silnik do gry.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.mapeditor.org/"&gt;Tiled&lt;/a&gt; - Darmowy&lt;/p&gt;
&lt;p&gt;Ze wszystkich programów z Tiled korzystam chyba najwięcej. Jest to prosty i intuicyjny edytor poziomów do gier.  Mimo swojej prostoty pozwala jednak na wiele. Po pierwsze możemy to z Tilei poukładać poziomy, dodać background.  Edytor posiada system warstw, dzięki czemu możemy w łatwy sposób dodać do mapy tła, obrazy oraz obiekty, które po odpowiednim zparsowaniu w silniku możemy używać jako miejsca kolizji, punkty startowe czy ścieżki dla sztucznej inteligencji. Ciekawą opcja jest implementacja w silniku autoreloadu plansz. Po spięciu takiej funkcjonalności z Tiled otrzymujemy możliwość edycji live naszych plansz. Cały projekt jest darmowy choć możemy wesprzeć twórcę dotacją lub zapłacić za edytor na itch.io. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Tiled" src="/images/gdtools/Tiled.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://dunin.itch.io/ptop"&gt;Paint of Persia&lt;/a&gt; - Darmowy&lt;/p&gt;
&lt;p&gt;Jest to bardzo ciekawe narzędzie pozwalające na tworzenie rotoskopowych animacji naszych gier. W skrócie polega to na tym, że nagrywamy kamerą lub bierzemy gotowy film i na jego podstawie możemy odrysować ruchy postaci. Takie podejście powoduje, że dostajemy bardzo realistyczną i szczegółową animacje postaci czy innych obiektów. Z ciekawostek taki sposób tworzenia animacji został po raz pierwszy wykorzystany w klasycznym Prince of Persia z 1989 roku.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Paint of Persia" src="/images/gdtools/pop.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pyxeledit.com/"&gt;Pyxel Edit&lt;/a&gt; Płatny&lt;/p&gt;
&lt;p&gt;Bardzo ciekawy program do tworzenia grafiki pixelartowej. Posiada on wsparcie do tworzenia tilesetów do map oraz animacji poklatkowej. Fajnym dodatkiem jest sugestia barw do cieniowania, rozjaśniania jest to szczególnie przydatne, jeżeli jest się takim antytalenciem graficznym jak ja.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Pyxel Edit" src="/images/gdtools/pyxeledit.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://krita.org/en/"&gt;Krita&lt;/a&gt; Darmowy&lt;/p&gt;
&lt;p&gt;Kolejny program graficzny tym razem nieco podobny z możliwościami do popularnego Photoshopa. U mnie świetnie się sprawdza do konceptów postaci czy plansz oraz rozrysowywania logiki. Koniecznie używajcie go z tabletem graficznym, ponieważ wtedy pokazuje prawdziwy pazur.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Krita" src="/images/gdtools/krita.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.gimp.org/"&gt;Gimp&lt;/a&gt; Darmowy&lt;/p&gt;
&lt;p&gt;Z obowiązku należy wspomnieć o tym programie graficznym. Wiem, że nadal jest popularny, ale mi obecnie zastępuję go w całości Krita, która działa szybciej i ma więcej fajnych możliwości. Mimo to Gimp jest nadal niezłą propozycją dla początkujących, ponieważ obsługa programu jest bajecznie prosta a jeżeli nie wiemy jak coś zrobić, to w sieci znajdziemy masę tutoriali, które na pewno nam pomogą.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://renderhjs.net/shoebox/"&gt;ShoeBox&lt;/a&gt; - Darmowy&lt;/p&gt;
&lt;p&gt;Shoebox może przy pierwszym podejściu wyglądać niepozornie, ale jest to tak na prawdę bardzo rozbudowane narzędzie do manipulacji teksturami. Przy jego pomocy możemy: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pakować tekstury w atlasy, &lt;/li&gt;
&lt;li&gt;ripować tekstury,&lt;/li&gt;
&lt;li&gt;odczytywać sprite'y np. SpriteFonty,&lt;/li&gt;
&lt;li&gt;generować BitmapFonty,&lt;/li&gt;
&lt;li&gt;pakować animacje ,&lt;/li&gt;
&lt;li&gt;dodawać pivot pointy(origin) do naszych sprite'ów,&lt;/li&gt;
&lt;li&gt;tworzyć nine slice sprite'y do UI,&lt;/li&gt;
&lt;li&gt;inne pomniejsze funkcjonalności.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jak widać jest tego sporo. Program polecam również dlatego, że jest darmowy a napisanie importera do wygenerowanych poprzez niego atlasów i spritesheet'ów nie powinno być problemem.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Shoebox" src="/images/gdtools/shoebox.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.codeandweb.com/texturepacker"&gt;TexturePacker&lt;/a&gt; Płatny&lt;/p&gt;
&lt;p&gt;Ostanie narzędzie to typowy packer pozwalający na stworzenie spritesheet'ów lub atlasów tekstur. Dodatkowo program pozwala na optymalizacje assetów poprzez kompresje, co daje nam lżejsze assety np. na komórkach, gdzie ekran jest mniejszy, przez co nie widać różnicy. Z programem współpracuje sporo silników dostępnych na rynku, ale nie ma też problemu w napisaniu własnego importera.&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category><category term="Tools"></category></entry><entry><title>2DXngine: aktualizacja po pierwszym tygodniu</title><link href="http://localhost:8000/2dxngine-aktualizacja-po-pierwszym-tygodniu.html" rel="alternate"></link><published>2017-03-10T19:40:00+01:00</published><updated>2017-03-10T19:40:00+01:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-03-10:/2dxngine-aktualizacja-po-pierwszym-tygodniu.html</id><summary type="html">&lt;p&gt;Cześć, jako, że mija pierwszy tydzień developmentu należało by wrzucić jakiś status update dotyczący projektu konkursowego. Jak wiadomo początki są trudne. Instalacja bibliotek ciągła się w nieskończoność, ale w końcu się udało. Ogólna struktura projektu w Visual Studio wygląda następująco:
&lt;img alt="2DXngine struktura projektu" src="/images/engine_project.png"&gt; 
Tak jak napisałem nie mam jakiś alternatywnych build systemów, a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć, jako, że mija pierwszy tydzień developmentu należało by wrzucić jakiś status update dotyczący projektu konkursowego. Jak wiadomo początki są trudne. Instalacja bibliotek ciągła się w nieskończoność, ale w końcu się udało. Ogólna struktura projektu w Visual Studio wygląda następująco:
&lt;img alt="2DXngine struktura projektu" src="/images/engine_project.png"&gt; 
Tak jak napisałem nie mam jakiś alternatywnych build systemów, a chciałem mieć testy, stąd taka a nie inna struktura, ponieważ w C++ testy odpalają się normalnie z exe, a to co chcę testować musi być biblioteką. Jeżeli ma ktoś inny pomysł jak zrobić to lepiej to czekam, bo obecna konfiguracja idealna nie jest, ale pozwala pracować w miarę stosując TDD. Z tymi testami jeszcze zobaczymy jak będzie, ponieważ pewnie nie będę w stanie przetestować wszystkiego np. generowanie grafiki czy bardziej złożone interakcje. 
Zaimplementowałem podstawową klasę aplikacji dla Windowsa. Wyświetla ona okienko, inicjalizuje podstawowe zmienne, odpala pętle główną i będzie podstawą reszty silnika. Dodatkowo udało mi się dodać service locator i timer.
W trakcie implementacji jest system GameObjectów i scen, ponieważ te komponenty są od siebie zależne muszę je na razie implementować równolegle. Obecnie mocno działam, aby skończyć implementacje systemu komponentów. Niestety blokuje mnie na razie to jak zrobić w C++ system rozpoznawania typów obiektów. Nie chcę używać standardowego RTTI dlatego, że mądrzejsi ode mnie twierdzą, że wolne to i nie powinno się w grach tego stosować. Mocno zagłębiłem się już w ten temat i znalazłem parę przykładów implementacji, więc myślę, że na dniach uda mi się to skończyć możliwe, że nawet kiedy czytacie ten tekst system jest już w miarę ogarnięty. Poza tym kiedy uda mi się to zrobić planuję artkułów na ten temat, bo temat jest ciekawy i potrzebny.
Staram się również w miarę możliwości aktualizować &lt;a href="https://trello.com/b/wJGa7Jm5/2dxngine"&gt;tablice&lt;/a&gt; na trello. Na chwilę obecną pare tasków zyskało checklisty a parę nowych tasków dojdzie do implementacji.
Z rzeczy których nie udało się zrobić to niestety nie udało mi się mierzyć czasu na toggl jak początkowo planowałem, więc będę musiał to zrobić od tej soboty, ponieważ planuje, że tydzień prac będę liczył od soboty do piątku. &lt;/p&gt;</content><category term="DSP2017"></category><category term="2DXngine"></category></entry><entry><title>Ogólna architektura silnika - system scen</title><link href="http://localhost:8000/ogolna-architektura-silnika-system-scen.html" rel="alternate"></link><published>2017-03-08T17:10:00+01:00</published><updated>2017-03-08T17:10:00+01:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-03-08:/ogolna-architektura-silnika-system-scen.html</id><summary type="html">&lt;p&gt;Dziś  trochę więcej opowiem na temat wysokopoziomowych wzorców stosowanych w grach komputerowych. Opisana poprzednio w artykule pętla gry jest bardzo nisko poziomowym elementem, mimo to jest niezbędna do implementacji dalszych podsystemów gry. System scen jest moim zdaniem drugim elementem, który dobrze jest zaimplementować, aby grę można było w łatwy sposób …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Dziś  trochę więcej opowiem na temat wysokopoziomowych wzorców stosowanych w grach komputerowych. Opisana poprzednio w artykule pętla gry jest bardzo nisko poziomowym elementem, mimo to jest niezbędna do implementacji dalszych podsystemów gry. System scen jest moim zdaniem drugim elementem, który dobrze jest zaimplementować, aby grę można było w łatwy sposób rozwijać.
Generalnie w implementacji chodzi o funkcjonalne podzielenie stanów aplikacji, co obrazuje poniższy rysunek:&lt;/p&gt;
&lt;p&gt;&lt;img alt="stany gry" src="/images/scene_graph.png"&gt;&lt;/p&gt;
&lt;p&gt;Sama nazwa  "scena" wzięła się od tego, że grę komputerową można postrzegać jako pewno rodzaju przedstawienie, w którym obiekty na scenie są aktorami na planszy, która jest dla nich swoistą sceną. Aby taki pomysł w grze mógł zaistnieć potrzebujemy dwóch rzeczy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;manager scen - jest to trzon całego systemu (do niego dodajemy i usuwamy sceny); odatkowo powinien on zarządzać, którą scenę należy uaktywnić,&lt;/li&gt;
&lt;li&gt;scena - bazowa abstrakcja z której czerpią pozostałe sceny; powinna ona posiadać możliwości aktualizacji aktorów oraz ich rysowania.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Można także dodać do sceny ładowanie specyficznej dla nich zawartości czy zapis ich stanu (choć ta ostatnia opcja jest zbędna, jeżeli mamy sensowny system zapisu gry). Ja często robię jeszcze parę dodatkowych abstrakcji np. UI Sceny czy Gameplay Sceny pozwalają one np. załadować się z pliku. Taka implementacja jest przydatna szczególnie, jeśli posiadamy w silniku edytor, który wygeneruje dla nas odpowiednie zasoby.
Ciekawą opcja jest dodanie do sceny czegoś na kształ zachowań odpalanych przed lub po aktualizacji stanu wszytkich obiektów na scenie. 
Takie podsystemy sceny można wykorzystać do np.:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wykrywania kolizji pomiędzy aktorami na scenie,&lt;/li&gt;
&lt;li&gt;naliczania czasowych bonusów/kar dla danych aktorów,&lt;/li&gt;
&lt;li&gt;interakcji pomiędzy aktorami,&lt;/li&gt;
&lt;li&gt;zbierania przedmiotów,&lt;/li&gt;
&lt;li&gt;cyklicznego zapisu stanu gry,&lt;/li&gt;
&lt;li&gt;Itd…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;System scen można jeszcze rozbudować o manager aktorów, który pozwoli na komfortowe ich wyszukiwanie w momencie kiedy będą nam do czegoś potrzebni.  To tyle jeśli chodzi o sceny i zarządzanie nimi, w następnym poście przejdę do game objectów. Na pewno temat będę jeszcze rozbudowywał przy innych elementach silnika, ale na razie tyle powinno wystarczyć.  &lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category></entry><entry><title>Ogólna architektura silnika - pętla gry</title><link href="http://localhost:8000/ogolna-architektura-silnika-petla-gry.html" rel="alternate"></link><published>2017-03-04T18:00:00+01:00</published><updated>2017-03-04T18:00:00+01:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-03-04:/ogolna-architektura-silnika-petla-gry.html</id><summary type="html">&lt;p&gt;Elementem, który posiada każdy silnik do gier jest pętla gry. W skrócie jest to element, który cyklicznie wykonuje całą logikę naszej gry. Wszystkie gry posiadają pewne stałe elementy, które muszą być wykonane, aby całość systemu działała.&lt;/p&gt;
&lt;p&gt;W największym uproszczeniu gra co klatkę powinna:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sprawdzić sygnały z urządzeń wejścia,&lt;/li&gt;
&lt;li&gt;na podstawie …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Elementem, który posiada każdy silnik do gier jest pętla gry. W skrócie jest to element, który cyklicznie wykonuje całą logikę naszej gry. Wszystkie gry posiadają pewne stałe elementy, które muszą być wykonane, aby całość systemu działała.&lt;/p&gt;
&lt;p&gt;W największym uproszczeniu gra co klatkę powinna:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sprawdzić sygnały z urządzeń wejścia,&lt;/li&gt;
&lt;li&gt;na podstawie tych sygnałów wykonać logikę wszystkich obiektów uczestniczących w grze,&lt;/li&gt;
&lt;li&gt;po wykonaniu logiki narysować wszystko oraz wyświetlić to użytkownikowi.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;W najprostszym ujęciu pseudokodu (wiem miało być bez kodu, ale się nie da) powinno to wygląd tak:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;HandleInput&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Draw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;If&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exitCondition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;Exit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;W takim ujęciu pętla wykona się tyle razy ile pozwoli na to procesor. Takiej sytuacji chcemy uniknąć, ponieważ w grze wiele rzeczy opiera się o upływ czasu musimy, więc obliczyć ile czasu upłynęło nam pomiędzy kolejnymi klatkami. Gry najczęściej działają w 60 fps lub w 30 fps, czyli na klatkę mamy 16 ms lub 30 ms. Aby zmierzyć czas powinniśmy zaimplementować timer, który zmierzy nam czas pomiędzy kolejnymi klatkami. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;timeStep&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;/&lt;/span&gt; &lt;span class="m"&gt;30f&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;30f&lt;/span&gt;&lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt; &lt;span class="m"&gt;60&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;60f&lt;/span&gt;&lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;accumulator&lt;/span&gt;  &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;timer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;deltaTime&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;timer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ElapsedTime&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;accumulator&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;accumulator&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;deltaTime&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;HandleInput&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accumulator&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;_timeStep&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;deltaTime&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;accumulator&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;accumulator&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="n"&gt;deltaTime&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;Draw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;deltaTime&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;If&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exitCondition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;Exit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dzięki zastosowaniu timera w powyższym kodzie update wykona się tylko przy zdefiniowanym kroku czasu. Aby mieć  pewność, że czas płynie bardzo dokładnie stosuje się inne sztuczki. Mnie jednak nie było to nigdy potrzebne, gdyby jednak kogoś to mega interesowało to polecam artykuł &lt;a href="http://gafferongames.com/game-physics/fix-your-timestep/"&gt;TU&lt;/a&gt; tam znajdziecie jeszcze więcej sposobów odmierzania czasu w pentli gry. Dodam jeszcze, że często nie będziecie musieli pisać kodu pętli gry, ponieważ większość frameworków czy bibliotek (Monogame, LibGDX, Phaser.js, itp.) posiada już własną implementacje. Mimo to warto wiedzieć co znajduje się w bebechach, żeby zrozumieć wysokopoziomową logikę. To tyle, kolejny wpis przejdzie na nieco wyższy poziom abstrakcji w implementowaniu własnego silnika.&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category></entry><entry><title>2DXngine: start projektu</title><link href="http://localhost:8000/2dxngine-start-projektu.html" rel="alternate"></link><published>2017-03-01T16:00:00+01:00</published><updated>2017-03-01T16:00:00+01:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-03-01:/2dxngine-start-projektu.html</id><summary type="html">&lt;p&gt;Cześć,
Jako, że "Daj Się Poznać 2017" dziś wystartowało, to ja również chciałbym wystartować z projektem konkursowmym.
Po długim namyśle zdecydowałem się na napisanie silnika w C++. Zanim przejdę do pokazania co zrobiłem, chciałem po krótce  określić ramy projektu.  Napisanie kompletnego silnika z edytorem w czasie 3 miesięcy z moim …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cześć,
Jako, że "Daj Się Poznać 2017" dziś wystartowało, to ja również chciałbym wystartować z projektem konkursowmym.
Po długim namyśle zdecydowałem się na napisanie silnika w C++. Zanim przejdę do pokazania co zrobiłem, chciałem po krótce  określić ramy projektu.  Napisanie kompletnego silnika z edytorem w czasie 3 miesięcy z moim obecnym stanem wiedzy o C++ jest nierealne, więc  ograniczyłem zakres prac tak, aby udało się zrobić coś działającego. 
Do implementacji tzw.  "must have" powinny wejść:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;game objecty z component modelem,&lt;/li&gt;
&lt;li&gt;bazowe komponenty,&lt;/li&gt;
&lt;li&gt;system scen,&lt;/li&gt;
&lt;li&gt;system sztucznej inteligencji oparty na drzewach zachowań,&lt;/li&gt;
&lt;li&gt;asset loader,&lt;/li&gt;
&lt;li&gt;obsługa dźwięku i muzyki,&lt;/li&gt;
&lt;li&gt;renderer 2D pozwalający na obsługę shaderów GLSL,&lt;/li&gt;
&lt;li&gt;wczytywanie animacji poklatkowych,&lt;/li&gt;
&lt;li&gt;prosty system fizyki i/lub integracja z Box2D,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Przygotowałem jeszcze takie rzeczy z kategorii "nice to have" (gdy uda mi się zaimplementować rzeczy z powyższej listy):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wczytywanie mapy z plików Tmx generowanych przez edytor Tiled,&lt;/li&gt;
&lt;li&gt;możliwość pracowania z Tiled w trybie livereload,&lt;/li&gt;
&lt;li&gt;kompilator assetów pozwalający je pakować w zdefiniowane paczki,&lt;/li&gt;
&lt;li&gt;streaming poziomów pozwalający doczytywać dynamiczne dane (pozwoli to na wyeliminowanie doczytywania pomiędzy lokacjami),&lt;/li&gt;
&lt;li&gt;integracja z językiem skryptowym Lua.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ze wszystkich "nice to have" najfajniej było by zrobić te z Tiledem oraz skryptowanie Lua, ale zobaczymy jak mi pójdzie.
Kolejną fajną rzeczą była by wielowątkowa pętla gry z render commandami, ale to już wyższa szkoła jazdy i na pewno teraz nie dam rady tego zaimplementować. 
Jako, że projekt startuje nie będzie w tym poście za dużo kodu raczej opowiem o tym co i jak będę robił. 
Po pierwsze link do repo na github jest -&amp;gt; &lt;a href="https://github.com/Harunx9/2DXngine"&gt;TU&lt;/a&gt;. 
Druga sprawa to taka krótka prezentacja bibliotek z których będę korzystał:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDL2 - jest to bibliotek ułatwiająca wiele spraw mutliplatformowych takich jak korzystanie z systemu plików, wyświetlanie okienka, proste rysowanie 2D, przechwytywanie inputu z urządzeń wskazujących itd. Generalnie jest to taki toolbox pomagający pisać mniej kodu. Po więcej odsyłam do dokumentacji -&amp;gt; &lt;a href="https://wiki.libsdl.org/FrontPage"&gt;TU&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Glm - biblioteka matematyczna udostępniona przez G-Truc Creations  -&amp;gt; &lt;a href="https://www.opengl.org/sdk/libs/GLM/"&gt;TU&lt;/a&gt;. Jest to lib typu single header więc wystarcza jeden plik nagłówkowy aby jej używać. Dodatkowo zawiera ona wszystkie typy matematyczne takie jak macierze czy wektory które potrzebne są w pracy z opengl.&lt;/li&gt;
&lt;li&gt;GLEW - bibliotek pozwalająca pisać multiplatformowy kod OpenGl. Teoretycznie do renderowania grafiki mógłbym użyć tego co daje mi SDL2, ale musiałbym zrezygnować z shaderów. Ze wzgleu na to, że shadery dają fajne możliwości do robienia efektów specjalnych renderer 2D zaimplementuję sam co pozwoli na skorzystanie z całości API OpenGL 4+.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Z ciekawych rzeczy myślałem aby użyć jakiegoś multiplatformowego build systemu np. Cmake czy Scons. Po namyśle stwierdziłem jednak, że na razie będę używał tego co oferuje w temacie Visual Studio 2015, czyli MSBuild. Jeśli w przyszłości zajdzie taka potrzeba spróbuje coś zmienić w tym temacie.
Kolejną sprawą jest jakość kodu. Postaram się z mojej strony wykorzystywać nowości języka C++ a, że jest ich sporo to pewnie nieraz będę się zastanawiał co wybrać. 
Drugą sprawą w temacie jakości jest pisanie kodu zgodnie z zasadami Data-Oriented Design. Jeżeli ktoś nie wie o czym mówię polecam obejrzeć tą prezentacje -&amp;gt; &lt;a href="https://www.youtube.com/watch?v=rX0ItVEVjHc"&gt;TU&lt;/a&gt;. 
W telegraficznym skrócie chodzi o to, aby tworzyć kod przyjazny dla cache naszego procesora a nie koniecznie z zasadami SOLID. Pozwala to bardzo mocno zoptymalizować czas wykonania algorytmów. Jak sam się poduczę tego to napiszę o tym jakiś osobny wpis. 
Ostatnią sprawą jest moja potrzeba porządkowania i mierzenia swojej pracy. Zobaczymy jak to pójdzie ale engine będzie miał taki quasi kanbanowy board na Trello będę się starał tam wypisywać taski jakie realizuje -&amp;gt; &lt;a href="https://trello.com/b/wJGa7Jm5/2dxngine"&gt;TU&lt;/a&gt;. Poza tym po pierwszym miesiącu postaram się zdać raport ile godzin udało mi się zainwestować w rozwój silnika.
To chyba na tyle w tym tygodniu postaram się pospinać biblioteki uporządkować repo i zrobić jakieś takie podstawy na których potem będziemy budować resztę silnika.&lt;/p&gt;
&lt;p&gt;PS. Taski na Trello są na razie bardzo ogóle podejrzewam, że jak będę implementował konkretny feature to to jakoś podzielę.&lt;/p&gt;</content><category term="DSP2017"></category><category term="2DXngine"></category></entry><entry><title>Ogólna architektura silnika - start</title><link href="http://localhost:8000/ogolna-architektura-silnika-start.html" rel="alternate"></link><published>2017-02-27T01:00:00+01:00</published><updated>2017-02-27T01:00:00+01:00</updated><author><name>Szymon Wanot</name></author><id>tag:localhost,2017-02-27:/ogolna-architektura-silnika-start.html</id><summary type="html">&lt;p&gt;Jak już pisałem wcześniej chciałbym tego bloga poprowadzić bardziej w stronę tematów związanych z tworzeniem gier komputerowych. Zacznę od ogólnej architektury, czyli tego jak ja bym wydział to jak zaimplementować silnik. Doświadczenia może nie mam dużego, ale już parę mniejszych gierek napisałem z lepszym lub gorszym skutkiem, więc wyciągnołem jakieś …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Jak już pisałem wcześniej chciałbym tego bloga poprowadzić bardziej w stronę tematów związanych z tworzeniem gier komputerowych. Zacznę od ogólnej architektury, czyli tego jak ja bym wydział to jak zaimplementować silnik. Doświadczenia może nie mam dużego, ale już parę mniejszych gierek napisałem z lepszym lub gorszym skutkiem, więc wyciągnołem jakieś wnioski i postaram się je zaprezentować. Jeżeli ktoś z was ma jakieś ciekawe przemyślenia to liczę na dyskusję. Całość podzielę na kilka artykułów, aby łatwiej się było odnaleźć, dodatkowo przykłady postaram oprzeć nie o kod a o rysunki, ponieważ to o czym będę pisał jest niezależne od języka czy paradygmatu programowania.
Lista tematów:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://harunx9.github.io/ogolna-architektura-silnika-petla-gry.html"&gt;pętla gry&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href="https://harunx9.github.io/ogolna-architektura-silnika-system-scen.html"&gt;system scen&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;system encji/GameObject'ów,&lt;/li&gt;
&lt;li&gt;system zawartości,&lt;/li&gt;
&lt;li&gt;sztuczna inteligencja,&lt;/li&gt;
&lt;li&gt;dźwięki i muzyka.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ps. Posty z tej serii zaczną ukazywać się już w tym tygodniu&lt;/p&gt;</content><category term="DSP2017"></category><category term="Gamedev"></category></entry></feed>