<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Programming warfare - gamedev</title><link>http://localhost:8000/</link><description></description><lastBuildDate>Sat, 28 Oct 2017 16:00:00 +0200</lastBuildDate><item><title>2DXngine tutorial - Engine overview</title><link>http://localhost:8000/2dxngine-tutorial-engine-overview.html</link><description>&lt;p&gt;Hi everyone. This will be my first post in English, so I believe that it will be worst. I've made decision lately about that to make some simple 2DXngine tutorial. Writeing this in English language can reach bigger audience I believe. Let's start from the beginning. 2DXngine is my project …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sat, 28 Oct 2017 16:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-10-28:/2dxngine-tutorial-engine-overview.html</guid><category>2DXngineTutorial</category><category>2DXngine</category><category>gamedev</category></item><item><title>PugiXML, czyli proste prasowanie XML w C/C++</title><link>http://localhost:8000/pugixml-czyli-proste-prasowanie-xml-w-cc.html</link><description>&lt;p&gt;Cześć. Jakiś czas temu stanąłem przed potrzebą wyboru jakiegoś rozwiązania do pracy z plikami XML. W C/C++ jest kilka bibliotek do obsługi XML'i:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TinyXML,&lt;/li&gt;
&lt;li&gt;RapidXML,&lt;/li&gt;
&lt;li&gt;LibXML2,&lt;/li&gt;
&lt;li&gt;BoostXML,&lt;/li&gt;
&lt;li&gt;PugiXML.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jak pewnie można się domyślić po tytule, to mój wybór padł na bibliotekę &lt;a href="https://pugixml.org/"&gt;pugixml&lt;/a&gt;. Wybrałem tak dlatego, że jej Api najbardziej …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Wed, 11 Oct 2017 19:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-10-11:/pugixml-czyli-proste-prasowanie-xml-w-cc.html</guid><category>programming</category><category>Gamedev</category></item><item><title>Renderowanie 2D cześć 6: Tekst True Type Font</title><link>http://localhost:8000/renderowanie-2d-czesc-6-tekst-true-type-font.html</link><description>&lt;p&gt;Renderowanie tekstu jest nieco bardziej skomplikowane od wyświetlania prostych obrazków. Wyświetlanie tekstu możemy zrealizować na dwa sposoby:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;renderowanie SpriteFontów,&lt;/li&gt;
&lt;li&gt;renderowanie True Type Font. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pierwszy sposób polega na wygenerowaniu sobie z pliku czcionki tekstury oraz pliku opisującego układ znaków na teksturze. Potem podczas renderowania wycinamy za pomocą tych danych odpowiednie obszary …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sun, 06 Aug 2017 13:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-08-06:/renderowanie-2d-czesc-6-tekst-true-type-font.html</guid><category>Gamedev</category><category>OpenGL</category></item><item><title>Konfiguracja aplikacji za pomocą plików ini</title><link>http://localhost:8000/konfiguracja-aplikacji-za-pomoca-plikow-ini.html</link><description>&lt;p&gt;Cześć. Dziś zajmiemy się konfiguracją aplikacji w C++. Temat przedstawię od strony mojego silnika 2DXngine. W przypadku C++ temat zewnętrznej konfiguracji nie jest tak oczywisty jak w przypadku C# i .NET, gdzie mamy pliki App i Web config. Taką konfiguracje w C++ możemy zapisać w plikach XML, ale jest to …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Fri, 21 Jul 2017 21:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-07-21:/konfiguracja-aplikacji-za-pomoca-plikow-ini.html</guid><category>programming</category><category>Gamedev</category></item><item><title>SDL_mixer, czyli szybka implementacja audio</title><link>http://localhost:8000/sdl_mixer-czyli-szybka-implementacja-audio.html</link><description>&lt;p&gt;Prawdopodobnie każdy twórca gier chce, by jego gra powodowała większą immersję, dlatego też należałoby do niej dodać oprócz grafiki takżę dźwięk oraz muzykę. 
Ze względu na to, że 2DXngine używa SDL2 postanowiłem iść dalej tą drogą i do odczytywania wykorzystać plugin SDL_mixer. Jest to mała wtyczka do SDL2, która pozwala …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sun, 09 Jul 2017 21:20:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-07-09:/sdl_mixer-czyli-szybka-implementacja-audio.html</guid><category>Gamedev</category></item><item><title>Renderowanie 2D cześć 5: Kamera</title><link>http://localhost:8000/renderowanie-2d-czesc-5-kamera.html</link><description>&lt;p&gt;Cześć. W poprzednich artykułach opisałem jak zaimplementowałem renderowanie 2D, dziś jeszcze jeden element dotyczący grafiki, czyli kamera 2D. Kamera jest elementem za pomocą, którego możemy manipulować viewport'em.
Sam interfejs klasy kamery jest dość prosty:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Camera&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Camera&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;viewportWidth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;viewportHeight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Camera&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="nf"&gt;get_rotation&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_rotation …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sun, 02 Jul 2017 14:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-07-02:/renderowanie-2d-czesc-5-kamera.html</guid><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2D część 4.2: Spritebatch</title><link>http://localhost:8000/renderowanie-2d-czesc-42-spritebatch.html</link><description>&lt;p&gt;Cześć. W poprzedniej części napisałem nieco o tym jak przebiega rysowanie a właściwie dokładanie elementów do narysowania. W tym artykule zajmiemy się dokładnie tym jak działa pipeline rysowania SpriteBatchem. Aby narysować jaką teksturę należy napisać taki oto kodzik:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_device&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Colors&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;black&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;batch&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextureWrap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;REPEAT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TextureFilter&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;POINT_FILTER&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;batch …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Wed, 21 Jun 2017 19:30:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-06-21:/renderowanie-2d-czesc-42-spritebatch.html</guid><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2D część 4.1: Spritebatch</title><link>http://localhost:8000/renderowanie-2d-czesc-41-spritebatch.html</link><description>&lt;p&gt;W poprzednich postach opisałem składowe potrzebne do napisania właściwego renderowania, dziś zajmiemy się właśnie Spritebatchem, który będzie służył w silniku 2DXngine do renderowania 2D. Zacznijmy jak zawsze od  interfejsu klasy, którą będziemy omawiać:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;FlipEffect&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NONE_FLIP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;FLIP_HORIZONTAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;FLIP_VERTICAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;SortMode&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NONE_SORT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;FRONT_TO_BACK&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;BACK_TO_FRONT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SpriteBatch&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;SpriteBatch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GraphicDevice&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;device&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;SpriteBatch …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sun, 18 Jun 2017 17:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-06-18:/renderowanie-2d-czesc-41-spritebatch.html</guid><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2d część 3: Sampler State</title><link>http://localhost:8000/renderowanie-2d-czesc-3-sampler-state.html</link><description>&lt;p&gt;Sampler to dość nowa rzecz w OpenGL, dostępna od wersji 3.3. Jest to taki kontener, który pozwala na przechowywanie parametrów potrzeb renderowania tekstur. Jego ustawienia są wykorzystywane przez fragment shader. W poprzednich wersjach OpenGL ustawienia te trzeba było ustawiać w teksturze przez funkcje glTexParameteri(), ale w momencie kiedy mamy …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sun, 11 Jun 2017 08:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-06-11:/renderowanie-2d-czesc-3-sampler-state.html</guid><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2D część 2: Shadery</title><link>http://localhost:8000/renderowanie-2d-czesc-2-shadery.html</link><description>&lt;p&gt;Shadery to programy wykonywane podczas procesu renderowania OpenGL. Nie będę tu opisywał całego pipeline, ponieważ to byłby temat na cały osobny artykuł, więc wspomnę tylko, że dla renderowania 2D istotne jest wipięcie się w fazę vertex shadera i fragment shadera. Ten pierwszy opowiada za umiejscowienie naszego spritea w przestrzeni, jego …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sat, 20 May 2017 18:50:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-05-20:/renderowanie-2d-czesc-2-shadery.html</guid><category>DSP2017</category><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2D część 1: Tekstury</title><link>http://localhost:8000/renderowanie-2d-czesc-1-tekstury.html</link><description>&lt;p&gt;Ostatnio udało mi się skończyć renderowanie w 2DXngine, chciałbym opisać jak działa zaimplementowane przeze mnie rozwiązanie. Zaczniemy od struktur danych, które są nam potrzebne aby działało renderowanie 2D. Jako pierwsze przyjrzymy się jak zaimplementować teksturę oraz jak ją wczytać z dysku, co nie do końca może być takie oczywiste w …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Wed, 17 May 2017 17:30:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-05-17:/renderowanie-2d-czesc-1-tekstury.html</guid><category>DSP2017</category><category>Gamedev</category><category>OpenGL</category></item><item><title>Gamedev przegląd technologii</title><link>http://localhost:8000/gamedev-przeglad-technologii.html</link><description>&lt;p&gt;Cześć. Dziś taki post z kategorii teoretyczno-poradnikowej. Mowa tu będzie o technologiach jakie polecam do tworzenia gier i dlaczego moim zdaniem ta a nie inna jest fajna. Traktujecie te przemyślenia nie jak prawdę objawioną, ale jako moje przemyślenia z perspektywy czasu. Od razu na początku chcę powiedzieć, że nie będzie …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Tue, 09 May 2017 20:50:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-05-09:/gamedev-przeglad-technologii.html</guid><category>DSP2017</category><category>Gamedev</category></item><item><title>Ogólna architektura silnika - sztuczna inteligencja</title><link>http://localhost:8000/ogolna-architektura-silnika-sztuczna-inteligencja.html</link><description>&lt;p&gt;Cześć. W dzisiejszych czasach bardzo popularne są gry sieciowe, więc opierające się o interakcje z innymi graczami. Mimo to sztuczna inteligencja nawet w  nich jest potrzeba, aby tworzyć bossów czy jakieś ciekawe eventy wraz z NPC w świecie gry. W dzisiejszym artykule przyjrzymy się jak stworzyć sztuczną inteligencje na miarę …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sat, 22 Apr 2017 18:30:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-04-22:/ogolna-architektura-silnika-sztuczna-inteligencja.html</guid><category>DSP2017</category><category>Gamedev</category></item><item><title>OpenGL a Unit Testy</title><link>http://localhost:8000/opengl-a-unit-testy.html</link><description>&lt;p&gt;Cześć. Wiem, że powinienem w pierwszej kolejności napisać o C++ i testowaniu, ale zeszło mi na to jakieś 3 godziny, więc może ktoś skorzysta z mojej wiedzy. Chciałem napisać prosty test sprawdzający czy klasa programu Shadera działa tak jak tego oczekuję. Napisałem więc prosty test, odpaliłem go i od tego …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Mon, 17 Apr 2017 18:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-04-17:/opengl-a-unit-testy.html</guid><category>DSP2017</category><category>Gamedev</category><category>Tools</category></item><item><title>Tworzenie gier w pojedynkę lub małym zespole. Czy to w ogóle możliwe?</title><link>http://localhost:8000/tworzenie-gier-w-pojedynke-lub-malym-zespole-czy-to-w-ogole-mozliwe.html</link><description>&lt;p&gt;Cześć. W poście o alternatywnych ścieżkach rozwoju w programowaniu opowiedziałem nieco jak ja się rozwijam jako programista. Teraz chciałem opowiedzieć o implementacji takiego modelu rozwoju w prawdziwym życiu. Tworzenie gier to bardzo fajne ciekawe i mega rozwijające hobby. Oprócz programowania trzeba poznać nieco matematyki, fizyki, architektury komputera, wzorców projektowych, tworzenia …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sun, 16 Apr 2017 14:15:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-04-16:/tworzenie-gier-w-pojedynke-lub-malym-zespole-czy-to-w-ogole-mozliwe.html</guid><category>DSP2017</category><category>Gamedev</category></item><item><title>Ogólna architektura silnika - component model</title><link>http://localhost:8000/ogolna-architektura-silnika-component-model.html</link><description>&lt;p&gt;Poprzedni post z tego cyklu traktował o tym jak tworzyć GameObjecty za pomocą hierarchii dziedziczenia. Jak już pisałem sposób ten staje się nieczytelny, w miarę rozwoju projektu, ale pozwala szybko wystartować. Dla większych gier GameObjecty tworzymy w nieco inny sposób używając nie dziedziczenia, a kompozycji stąd nazwa component model. W …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Tue, 11 Apr 2017 18:20:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-04-11:/ogolna-architektura-silnika-component-model.html</guid><category>DSP2017</category><category>Gamedev</category></item><item><title>Eventy jak w C# w C++</title><link>http://localhost:8000/eventy-jak-w-c-w-c.html</link><description>&lt;p&gt;Cześć.
Niestety w tym tygodniu nie miałem czasu za dużo popracować nad silnikiem. Co prawda pisze system scen, ale mam to tak rozgrzebane, że nie jestem w stanie tego podsumować. Mimo tego udało mi się zrobić jedną fajną rzecz, którą chciałem się z wami podzielić. Implementując silnik pomyślałem, że będę …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Fri, 31 Mar 2017 21:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-03-31:/eventy-jak-w-c-w-c.html</guid><category>DSP2017</category><category>Gamedev</category><category>Tools</category></item><item><title>Własny TypeInfo w C++</title><link>http://localhost:8000/wlasny-typeinfo-w-c.html</link><description>&lt;p&gt;Cześć, dziś chciałem pokazać jak zrobiłem system informacji o typach obiektów w silniku 2DXngine, który powstaje w ramach konkursu "Daj się poznać". Taki feature był mi porzebny do wysukiwania po typie komponentów z GameObjectu. Nie chciałem używać standardowego  TypeId, ponieważ mądrzejsi ode mnie mówią, że jest to powolne, i że …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Mon, 27 Mar 2017 19:10:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-03-27:/wlasny-typeinfo-w-c.html</guid><category>DSP2017</category><category>Gamedev</category><category>C++</category></item><item><title>Ogólna architektura silnika - system Encji/GameObject'ów</title><link>http://localhost:8000/ogolna-architektura-silnika-system-encjigameobjectow.html</link><description>&lt;p&gt;Ostatni post tego cyklu był o zarządzaniu scenami, dziś postaram się nieco napisać o tym co powinno być na scenie, aby gra posiadała jakiś gameplay. Mowa tu będzie o Aktorach, Encjach lub GameObjetach w zależności od biblioteki/engine'u nazwa może się różnić, ale to ciągle to samo. Takim elementem może …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Tue, 21 Mar 2017 18:20:00 +0100</pubDate><guid isPermaLink="false">tag:localhost,2017-03-21:/ogolna-architektura-silnika-system-encjigameobjectow.html</guid><category>DSP2017</category><category>Gamedev</category></item><item><title>Narzędzia przydatne w tworzeniu gier</title><link>http://localhost:8000/narzedzia-przydatne-w-tworzeniu-gier.html</link><description>&lt;p&gt;Jako, że słowo się rzekło, teraz więcej postów o tematyce związanej z szeroko pojętym gamedevem. Dziś chciałbym przybliżyć wam kilka fajnych narzędzi, które można wykorzystać tworząc własny silnik do gry.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.mapeditor.org/"&gt;Tiled&lt;/a&gt; - Darmowy&lt;/p&gt;
&lt;p&gt;Ze wszystkich programów z Tiled korzystam chyba najwięcej. Jest to prosty i intuicyjny edytor poziomów do gier.  Mimo …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Wed, 15 Mar 2017 20:00:00 +0100</pubDate><guid isPermaLink="false">tag:localhost,2017-03-15:/narzedzia-przydatne-w-tworzeniu-gier.html</guid><category>DSP2017</category><category>Gamedev</category><category>Tools</category></item><item><title>Ogólna architektura silnika - system scen</title><link>http://localhost:8000/ogolna-architektura-silnika-system-scen.html</link><description>&lt;p&gt;Dziś  trochę więcej opowiem na temat wysokopoziomowych wzorców stosowanych w grach komputerowych. Opisana poprzednio w artykule pętla gry jest bardzo nisko poziomowym elementem, mimo to jest niezbędna do implementacji dalszych podsystemów gry. System scen jest moim zdaniem drugim elementem, który dobrze jest zaimplementować, aby grę można było w łatwy sposób …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Wed, 08 Mar 2017 17:10:00 +0100</pubDate><guid isPermaLink="false">tag:localhost,2017-03-08:/ogolna-architektura-silnika-system-scen.html</guid><category>DSP2017</category><category>Gamedev</category></item><item><title>Ogólna architektura silnika - pętla gry</title><link>http://localhost:8000/ogolna-architektura-silnika-petla-gry.html</link><description>&lt;p&gt;Elementem, który posiada każdy silnik do gier jest pętla gry. W skrócie jest to element, który cyklicznie wykonuje całą logikę naszej gry. Wszystkie gry posiadają pewne stałe elementy, które muszą być wykonane, aby całość systemu działała.&lt;/p&gt;
&lt;p&gt;W największym uproszczeniu gra co klatkę powinna:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sprawdzić sygnały z urządzeń wejścia,&lt;/li&gt;
&lt;li&gt;na podstawie …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sat, 04 Mar 2017 18:00:00 +0100</pubDate><guid isPermaLink="false">tag:localhost,2017-03-04:/ogolna-architektura-silnika-petla-gry.html</guid><category>DSP2017</category><category>Gamedev</category></item><item><title>Ogólna architektura silnika - start</title><link>http://localhost:8000/ogolna-architektura-silnika-start.html</link><description>&lt;p&gt;Jak już pisałem wcześniej chciałbym tego bloga poprowadzić bardziej w stronę tematów związanych z tworzeniem gier komputerowych. Zacznę od ogólnej architektury, czyli tego jak ja bym wydział to jak zaimplementować silnik. Doświadczenia może nie mam dużego, ale już parę mniejszych gierek napisałem z lepszym lub gorszym skutkiem, więc wyciągnołem jakieś …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Mon, 27 Feb 2017 01:00:00 +0100</pubDate><guid isPermaLink="false">tag:localhost,2017-02-27:/ogolna-architektura-silnika-start.html</guid><category>DSP2017</category><category>Gamedev</category></item></channel></rss>