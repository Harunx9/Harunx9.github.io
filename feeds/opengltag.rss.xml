<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Programming warfare - OpenGL</title><link>http://localhost:8000/</link><description></description><lastBuildDate>Sun, 06 Aug 2017 13:00:00 +0200</lastBuildDate><item><title>Renderowanie 2D cześć 6: Tekst True Type Font</title><link>http://localhost:8000/renderowanie-2d-czesc-6-tekst-true-type-font.html</link><description>&lt;p&gt;Renderowanie tekstu jest nieco bardziej skomplikowane od wyświetlania prostych obrazków. Wyświetlanie tekstu możemy zrealizować na dwa sposoby:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;renderowanie SpriteFontów,&lt;/li&gt;
&lt;li&gt;renderowanie True Type Font. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pierwszy sposób polega na wygenerowaniu sobie z pliku czcionki tekstury oraz pliku opisującego układ znaków na teksturze. Potem podczas renderowania wycinamy za pomocą tych danych odpowiednie obszary …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sun, 06 Aug 2017 13:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-08-06:/renderowanie-2d-czesc-6-tekst-true-type-font.html</guid><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2D cześć 5: Kamera</title><link>http://localhost:8000/renderowanie-2d-czesc-5-kamera.html</link><description>&lt;p&gt;Cześć. W poprzednich artykułach opisałem jak zaimplementowałem renderowanie 2D, dziś jeszcze jeden element dotyczący grafiki, czyli kamera 2D. Kamera jest elementem za pomocą, którego możemy manipulować viewport'em.
Sam interfejs klasy kamery jest dość prosty:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Camera&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Camera&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;viewportWidth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;viewportHeight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Camera&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="nf"&gt;get_rotation&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_rotation …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sun, 02 Jul 2017 14:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-07-02:/renderowanie-2d-czesc-5-kamera.html</guid><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2D część 4.2: Spritebatch</title><link>http://localhost:8000/renderowanie-2d-czesc-42-spritebatch.html</link><description>&lt;p&gt;Cześć. W poprzedniej części napisałem nieco o tym jak przebiega rysowanie a właściwie dokładanie elementów do narysowania. W tym artykule zajmiemy się dokładnie tym jak działa pipeline rysowania SpriteBatchem. Aby narysować jaką teksturę należy napisać taki oto kodzik:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;_device&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Colors&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;black&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;batch&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextureWrap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;REPEAT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TextureFilter&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;POINT_FILTER&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;batch …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Wed, 21 Jun 2017 19:30:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-06-21:/renderowanie-2d-czesc-42-spritebatch.html</guid><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2D część 4.1: Spritebatch</title><link>http://localhost:8000/renderowanie-2d-czesc-41-spritebatch.html</link><description>&lt;p&gt;W poprzednich postach opisałem składowe potrzebne do napisania właściwego renderowania, dziś zajmiemy się właśnie Spritebatchem, który będzie służył w silniku 2DXngine do renderowania 2D. Zacznijmy jak zawsze od  interfejsu klasy, którą będziemy omawiać:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;FlipEffect&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NONE_FLIP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;FLIP_HORIZONTAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;FLIP_VERTICAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;SortMode&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NONE_SORT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;FRONT_TO_BACK&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;BACK_TO_FRONT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SpriteBatch&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;SpriteBatch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GraphicDevice&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;device&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;SpriteBatch …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sun, 18 Jun 2017 17:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-06-18:/renderowanie-2d-czesc-41-spritebatch.html</guid><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2d część 3: Sampler State</title><link>http://localhost:8000/renderowanie-2d-czesc-3-sampler-state.html</link><description>&lt;p&gt;Sampler to dość nowa rzecz w OpenGL, dostępna od wersji 3.3. Jest to taki kontener, który pozwala na przechowywanie parametrów potrzeb renderowania tekstur. Jego ustawienia są wykorzystywane przez fragment shader. W poprzednich wersjach OpenGL ustawienia te trzeba było ustawiać w teksturze przez funkcje glTexParameteri(), ale w momencie kiedy mamy …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sun, 11 Jun 2017 08:00:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-06-11:/renderowanie-2d-czesc-3-sampler-state.html</guid><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2D część 2: Shadery</title><link>http://localhost:8000/renderowanie-2d-czesc-2-shadery.html</link><description>&lt;p&gt;Shadery to programy wykonywane podczas procesu renderowania OpenGL. Nie będę tu opisywał całego pipeline, ponieważ to byłby temat na cały osobny artykuł, więc wspomnę tylko, że dla renderowania 2D istotne jest wipięcie się w fazę vertex shadera i fragment shadera. Ten pierwszy opowiada za umiejscowienie naszego spritea w przestrzeni, jego …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Sat, 20 May 2017 18:50:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-05-20:/renderowanie-2d-czesc-2-shadery.html</guid><category>DSP2017</category><category>Gamedev</category><category>OpenGL</category></item><item><title>Renderowanie 2D część 1: Tekstury</title><link>http://localhost:8000/renderowanie-2d-czesc-1-tekstury.html</link><description>&lt;p&gt;Ostatnio udało mi się skończyć renderowanie w 2DXngine, chciałbym opisać jak działa zaimplementowane przeze mnie rozwiązanie. Zaczniemy od struktur danych, które są nam potrzebne aby działało renderowanie 2D. Jako pierwsze przyjrzymy się jak zaimplementować teksturę oraz jak ją wczytać z dysku, co nie do końca może być takie oczywiste w …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Wanot</dc:creator><pubDate>Wed, 17 May 2017 17:30:00 +0200</pubDate><guid isPermaLink="false">tag:localhost,2017-05-17:/renderowanie-2d-czesc-1-tekstury.html</guid><category>DSP2017</category><category>Gamedev</category><category>OpenGL</category></item></channel></rss>